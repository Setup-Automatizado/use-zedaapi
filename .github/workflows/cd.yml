name: CD - Release & Deploy

on:
  push:
    branches:
      - production
      - homolog

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  GO_VERSION: "1.25"
  API_IMAGE_NAME: whatsapp-api
  MANAGER_IMAGE_NAME: manager-whatsapp-api

jobs:
  # ======================================
  # Job: Semantic Release
  # ======================================
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      new_release_major_version: ${{ steps.semantic.outputs.new_release_major_version }}
      new_release_minor_version: ${{ steps.semantic.outputs.new_release_minor_version }}
      new_release_patch_version: ${{ steps.semantic.outputs.new_release_patch_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: Install semantic-release dependencies
        run: |
          npm install -g \
            semantic-release@latest \
            @semantic-release/changelog@latest \
            @semantic-release/git@latest \
            @semantic-release/github@latest \
            @semantic-release/exec@latest \
            conventional-changelog-conventionalcommits@latest

      - name: Fetch all tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          git fetch --tags --force
          echo "ðŸ“‹ Tags existentes:"
          git tag -l | sort -V | tail -20

      - name: Run Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release || echo "No release needed or release already exists"

      - name: Display release info
        if: steps.semantic.outputs.new_release_published == 'true'
        run: |
          echo "ðŸŽ‰ New release published!"
          echo "Version: ${{ steps.semantic.outputs.new_release_version }}"
          echo "Major: ${{ steps.semantic.outputs.new_release_major_version }}"
          echo "Minor: ${{ steps.semantic.outputs.new_release_minor_version }}"
          echo "Patch: ${{ steps.semantic.outputs.new_release_patch_version }}"

  # ======================================
  # Job: Build & Push API Docker Image
  # ======================================
  docker-api:
    name: Build & Push API
    runs-on: ubuntu-latest
    needs: release
    if: always()
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine version tag
        id: version
        run: |
          if [ "${{ github.ref }}" = "refs/heads/production" ]; then
            if [ "${{ needs.release.outputs.new_release_published }}" = "true" ]; then
              VERSION="${{ needs.release.outputs.new_release_version }}"
              echo "VERSION=v${VERSION}" >> $GITHUB_OUTPUT
              echo "CHANNEL=latest" >> $GITHUB_OUTPUT
            else
              echo "VERSION=latest" >> $GITHUB_OUTPUT
              echo "CHANNEL=latest" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.ref }}" = "refs/heads/homolog" ]; then
            echo "VERSION=homolog" >> $GITHUB_OUTPUT
            echo "CHANNEL=homolog" >> $GITHUB_OUTPUT
          else
            echo "VERSION=unknown" >> $GITHUB_OUTPUT
            echo "CHANNEL=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Docker metadata for API
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.version.outputs.VERSION }}
            type=raw,value=${{ steps.version.outputs.CHANNEL }}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=WhatsApp API
            org.opencontainers.image.description=WhatsApp Web Multi-device API
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build and push API image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.version.outputs.VERSION }}
            COMMIT=${{ github.sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

      - name: Display API image info
        run: |
          echo "API Docker image pushed successfully!"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # ======================================
  # Job: Build & Push Manager Docker Image
  # ======================================
  docker-manager:
    name: Build & Push Manager
    runs-on: ubuntu-latest
    needs: release
    if: always()
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine version and URLs
        id: version
        run: |
          if [ "${{ github.ref }}" = "refs/heads/production" ]; then
            if [ "${{ needs.release.outputs.new_release_published }}" = "true" ]; then
              VERSION="${{ needs.release.outputs.new_release_version }}"
              echo "VERSION=v${VERSION}" >> $GITHUB_OUTPUT
            else
              echo "VERSION=latest" >> $GITHUB_OUTPUT
            fi
            echo "APP_URL=${{ secrets.MANAGER_APP_URL || 'https://manager.cloudfront.net' }}" >> $GITHUB_OUTPUT
            echo "API_PUBLIC_URL=${{ secrets.API_PUBLIC_URL || 'https://api.cloudfront.net' }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/homolog" ]; then
            echo "VERSION=homolog" >> $GITHUB_OUTPUT
            echo "APP_URL=http://homolog-manager-alb-936707116.us-east-1.elb.amazonaws.com" >> $GITHUB_OUTPUT
            echo "API_PUBLIC_URL=http://homolog-whatsmeow-alb-1474920577.us-east-1.elb.amazonaws.com" >> $GITHUB_OUTPUT
          else
            echo "VERSION=unknown" >> $GITHUB_OUTPUT
            echo "APP_URL=http://localhost:3000" >> $GITHUB_OUTPUT
            echo "API_PUBLIC_URL=http://localhost:8080" >> $GITHUB_OUTPUT
          fi

      - name: Docker metadata for Manager
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.MANAGER_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.version.outputs.VERSION }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/production' }}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=WhatsApp Manager
            org.opencontainers.image.description=WhatsApp API Manager Frontend
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build and push Manager image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./manager-whatsapp-api-golang
          file: ./manager-whatsapp-api-golang/Dockerfile
          target: runner
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_APP_URL=${{ steps.version.outputs.APP_URL }}
            NEXT_PUBLIC_WHATSAPP_API_URL=${{ steps.version.outputs.API_PUBLIC_URL }}
            NEXT_PUBLIC_API_BASE_URL=${{ steps.version.outputs.API_PUBLIC_URL }}
            VERSION=${{ steps.version.outputs.VERSION }}
            COMMIT=${{ github.sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

      - name: Build and push Manager migration image
        uses: docker/build-push-action@v5
        with:
          context: ./manager-whatsapp-api-golang
          file: ./manager-whatsapp-api-golang/Dockerfile
          target: migration
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.MANAGER_IMAGE_NAME }}:${{ steps.version.outputs.VERSION }}-migrate
          cache-from: type=gha

      - name: Display Manager image info
        run: |
          echo "Manager Docker image pushed successfully!"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # ======================================
  # Job: Deploy to AWS ECS
  # ======================================
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [release, docker-api, docker-manager]
    if: always() && (needs.docker-api.result == 'success' || needs.docker-manager.result == 'success')
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ github.ref == 'refs/heads/production' && 'production' || 'homolog' }}
      url: ${{ steps.url.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/production" ]; then
            echo "ENVIRONMENT=production" >> $GITHUB_OUTPUT
            echo "CLUSTER=production-whatsmeow-cluster" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/homolog" ]; then
            echo "ENVIRONMENT=homolog" >> $GITHUB_OUTPUT
            echo "CLUSTER=homolog-whatsmeow-cluster" >> $GITHUB_OUTPUT
          fi

      - name: Update API ECS Service
        if: needs.docker-api.result == 'success'
        run: |
          echo "Updating API service..."
          API_SERVICE="${{ steps.env.outputs.ENVIRONMENT }}-whatsmeow-service"

          # Check if service exists
          if aws ecs describe-services --cluster "${{ steps.env.outputs.CLUSTER }}" --services "$API_SERVICE" --region "${{ secrets.AWS_REGION }}" 2>/dev/null | grep -q '"status": "ACTIVE"'; then
            aws ecs update-service \
              --cluster "${{ steps.env.outputs.CLUSTER }}" \
              --service "$API_SERVICE" \
              --force-new-deployment \
              --region "${{ secrets.AWS_REGION }}"
            echo "API service updated: $API_SERVICE"
          else
            echo "::warning::API service not found: $API_SERVICE"
          fi

      - name: Update Manager ECS Service
        if: needs.docker-manager.result == 'success'
        run: |
          echo "Updating Manager service..."
          MANAGER_SERVICE="${{ steps.env.outputs.ENVIRONMENT }}-manager-service"

          # Check if service exists
          if aws ecs describe-services --cluster "${{ steps.env.outputs.CLUSTER }}" --services "$MANAGER_SERVICE" --region "${{ secrets.AWS_REGION }}" 2>/dev/null | grep -q '"status": "ACTIVE"'; then
            aws ecs update-service \
              --cluster "${{ steps.env.outputs.CLUSTER }}" \
              --service "$MANAGER_SERVICE" \
              --force-new-deployment \
              --region "${{ secrets.AWS_REGION }}"
            echo "Manager service updated: $MANAGER_SERVICE"
          else
            echo "::warning::Manager service not found: $MANAGER_SERVICE"
          fi

      - name: Wait for services to stabilize
        run: |
          echo "Waiting for services to stabilize..."

          API_SERVICE="${{ steps.env.outputs.ENVIRONMENT }}-whatsmeow-service"
          MANAGER_SERVICE="${{ steps.env.outputs.ENVIRONMENT }}-manager-service"

          # Wait for API service
          if aws ecs describe-services --cluster "${{ steps.env.outputs.CLUSTER }}" --services "$API_SERVICE" 2>/dev/null | grep -q '"status": "ACTIVE"'; then
            echo "Waiting for API service..."
            aws ecs wait services-stable \
              --cluster "${{ steps.env.outputs.CLUSTER }}" \
              --services "$API_SERVICE" || echo "API service wait timed out"
          fi

          # Wait for Manager service
          if aws ecs describe-services --cluster "${{ steps.env.outputs.CLUSTER }}" --services "$MANAGER_SERVICE" 2>/dev/null | grep -q '"status": "ACTIVE"'; then
            echo "Waiting for Manager service..."
            aws ecs wait services-stable \
              --cluster "${{ steps.env.outputs.CLUSTER }}" \
              --services "$MANAGER_SERVICE" || echo "Manager service wait timed out"
          fi

          echo "Services stabilization complete"

      - name: Get service URL
        id: url
        run: |
          API_SERVICE="${{ steps.env.outputs.ENVIRONMENT }}-whatsmeow-service"

          # Get load balancer DNS from API service
          TARGET_GROUP=$(aws ecs describe-services \
            --cluster "${{ steps.env.outputs.CLUSTER }}" \
            --services "$API_SERVICE" \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text 2>/dev/null || echo "None")

          if [ "$TARGET_GROUP" != "None" ] && [ -n "$TARGET_GROUP" ] && [ "$TARGET_GROUP" != "null" ]; then
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns "$TARGET_GROUP" \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text 2>/dev/null || echo "")

            if [ -n "$LB_ARN" ] && [ "$LB_ARN" != "null" ]; then
              DNS_NAME=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "$LB_ARN" \
                --query 'LoadBalancers[0].DNSName' \
                --output text 2>/dev/null || echo "")

              if [ -n "$DNS_NAME" ] && [ "$DNS_NAME" != "null" ]; then
                echo "SERVICE_URL=http://${DNS_NAME}" >> $GITHUB_OUTPUT
                echo "service_url=http://${DNS_NAME}" >> $GITHUB_OUTPUT
              else
                echo "SERVICE_URL=N/A" >> $GITHUB_OUTPUT
                echo "service_url=N/A" >> $GITHUB_OUTPUT
              fi
            else
              echo "SERVICE_URL=N/A" >> $GITHUB_OUTPUT
              echo "service_url=N/A" >> $GITHUB_OUTPUT
            fi
          else
            echo "SERVICE_URL=N/A" >> $GITHUB_OUTPUT
            echo "service_url=N/A" >> $GITHUB_OUTPUT
          fi

      - name: Deployment summary
        run: |
          echo "Deployment completed!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Cluster: ${{ steps.env.outputs.CLUSTER }}"
          echo "API Service: ${{ steps.env.outputs.ENVIRONMENT }}-whatsmeow-service"
          echo "Manager Service: ${{ steps.env.outputs.ENVIRONMENT }}-manager-service"
          echo "API URL: ${{ steps.url.outputs.SERVICE_URL }}"

  # ======================================
  # Job: Health Check
  # ======================================
  health-check:
    name: Post-Deploy Health Check
    runs-on: ubuntu-latest
    needs: deploy
    if: needs.deploy.result == 'success'
    steps:
      - name: Wait for service stabilization
        run: sleep 30

      - name: Health check
        id: health
        continue-on-error: true
        run: |
          URL="${{ needs.deploy.outputs.service_url }}/health"

          if [ "$URL" = "N/A/health" ]; then
            echo "âš ï¸ Service URL not available, skipping health check"
            exit 0
          fi

          MAX_RETRIES=5
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $URL || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Health check passed! (HTTP $HTTP_CODE)"
              exit 0
            else
              echo "âŒ Health check failed (HTTP $HTTP_CODE)"

              if [ $i -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            fi
          done

          echo "âŒ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Notify on failure
        if: failure()
        run: |
          echo "::warning::Health check failed after deployment"
          echo "::warning::Manual verification required"

  # ======================================
  # Job: Notification
  # ======================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [release, docker-api, docker-manager, deploy, health-check]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "STATUS=success" >> $GITHUB_OUTPUT
            echo "COLOR=good" >> $GITHUB_OUTPUT
            echo "EMOJI=âœ…" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" = "failure" ] || [ "${{ needs.docker-api.result }}" = "failure" ] || [ "${{ needs.docker-manager.result }}" = "failure" ]; then
            echo "STATUS=failure" >> $GITHUB_OUTPUT
            echo "COLOR=danger" >> $GITHUB_OUTPUT
            echo "EMOJI=âŒ" >> $GITHUB_OUTPUT
          else
            echo "STATUS=warning" >> $GITHUB_OUTPUT
            echo "COLOR=warning" >> $GITHUB_OUTPUT
            echo "EMOJI=âš ï¸" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ${{ steps.status.outputs.EMOJI }} Deployment Summary

          **Branch**: `${{ github.ref_name }}`
          **Commit**: `${{ github.sha }}`
          **Environment**: `${{ github.ref == 'refs/heads/production' && 'production' || 'homolog' }}`

          ### Results

          | Job | Status |
          |-----|--------|
          | Release | ${{ needs.release.result == 'success' && 'âœ…' || needs.release.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | API Build | ${{ needs.docker-api.result == 'success' && 'âœ…' || needs.docker-api.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Manager Build | ${{ needs.docker-manager.result == 'success' && 'âœ…' || needs.docker-manager.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Deploy | ${{ needs.deploy.result == 'success' && 'âœ…' || needs.deploy.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Health Check | ${{ needs.health-check.result == 'success' && 'âœ…' || needs.health-check.result == 'failure' && 'âŒ' || 'â­ï¸' }} |

          ### Version Info

          - **Version**: ${{ needs.release.outputs.new_release_version || 'No new release' }}
          - **API Tag**: `${{ needs.docker-api.outputs.image_tag }}`
          - **Manager Tag**: `${{ needs.docker-manager.outputs.image_tag }}`

          ---

          **Workflow**: [${{ github.workflow }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
