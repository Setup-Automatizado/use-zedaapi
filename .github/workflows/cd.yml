name: CD - Release & Deploy

on:
  push:
    branches:
      - main
      - develop
      - homolog

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  GO_VERSION: '1.25'
  DOCKER_IMAGE_NAME: whatsmeow-api
  AWS_REGION: us-east-1

jobs:
  # ======================================
  # Job: Semantic Release
  # ======================================
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      new_release_major_version: ${{ steps.semantic.outputs.new_release_major_version }}
      new_release_minor_version: ${{ steps.semantic.outputs.new_release_minor_version }}
      new_release_patch_version: ${{ steps.semantic.outputs.new_release_patch_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Install semantic-release dependencies
        run: |
          npm install -g \
            semantic-release@latest \
            @semantic-release/changelog@latest \
            @semantic-release/git@latest \
            @semantic-release/github@latest \
            @semantic-release/exec@latest \
            conventional-changelog-conventionalcommits@latest

      - name: Run Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release

      - name: Display release info
        if: steps.semantic.outputs.new_release_published == 'true'
        run: |
          echo "ðŸŽ‰ New release published!"
          echo "Version: ${{ steps.semantic.outputs.new_release_version }}"
          echo "Major: ${{ steps.semantic.outputs.new_release_major_version }}"
          echo "Minor: ${{ steps.semantic.outputs.new_release_minor_version }}"
          echo "Patch: ${{ steps.semantic.outputs.new_release_patch_version }}"

  # ======================================
  # Job: Build & Push Docker Images
  # ======================================
  docker:
    name: Build & Push Docker
    runs-on: ubuntu-latest
    needs: release
    if: always()
    permissions:
      id-token: write
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          token: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine version tag
        id: version
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            if [ "${{ needs.release.outputs.new_release_published }}" = "true" ]; then
              VERSION="${{ needs.release.outputs.new_release_version }}"
              echo "VERSION=v${VERSION}" >> $GITHUB_OUTPUT
              echo "CHANNEL=latest" >> $GITHUB_OUTPUT
            else
              echo "VERSION=latest" >> $GITHUB_OUTPUT
              echo "CHANNEL=latest" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "VERSION=develop" >> $GITHUB_OUTPUT
            echo "CHANNEL=develop" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/homolog" ]; then
            echo "VERSION=homolog" >> $GITHUB_OUTPUT
            echo "CHANNEL=homolog" >> $GITHUB_OUTPUT
          else
            echo "VERSION=unknown" >> $GITHUB_OUTPUT
            echo "CHANNEL=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.version.outputs.VERSION }}
            type=raw,value=${{ steps.version.outputs.CHANNEL }}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=WhatsApp API
            org.opencontainers.image.description=WhatsApp Web Multi-device API with Z-API compatibility
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.version.outputs.VERSION }}
            COMMIT=${{ github.sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

      - name: Display image info
        run: |
          echo "ðŸ³ Docker images pushed successfully!"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # ======================================
  # Job: Deploy to AWS ECS
  # ======================================
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [release, docker]
    if: always() && needs.docker.result == 'success'
    permissions:
      id-token: write
      contents: read
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || github.ref == 'refs/heads/develop' && 'staging' || 'homolog' }}
      url: ${{ steps.deploy.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "ENVIRONMENT=production" >> $GITHUB_OUTPUT
            echo "CLUSTER=whatsmeow-production" >> $GITHUB_OUTPUT
            echo "SERVICE=whatsmeow-api-service" >> $GITHUB_OUTPUT
            echo "TASK_FAMILY=whatsmeow-api-task" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_OUTPUT
            echo "CLUSTER=whatsmeow-staging" >> $GITHUB_OUTPUT
            echo "SERVICE=whatsmeow-api-service" >> $GITHUB_OUTPUT
            echo "TASK_FAMILY=whatsmeow-api-task" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/homolog" ]; then
            echo "ENVIRONMENT=homolog" >> $GITHUB_OUTPUT
            echo "CLUSTER=whatsmeow-homolog" >> $GITHUB_OUTPUT
            echo "SERVICE=whatsmeow-api-service" >> $GITHUB_OUTPUT
            echo "TASK_FAMILY=whatsmeow-api-task" >> $GITHUB_OUTPUT
          fi

      - name: Download task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ steps.env.outputs.TASK_FAMILY }} \
            --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ needs.docker.outputs.image_tag }}

      - name: Deploy Amazon ECS task definition
        id: deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ steps.env.outputs.SERVICE }}
          cluster: ${{ steps.env.outputs.CLUSTER }}
          wait-for-service-stability: true

      - name: Get service URL
        id: url
        run: |
          # Get load balancer DNS from service
          TARGET_GROUP=$(aws ecs describe-services \
            --cluster ${{ steps.env.outputs.CLUSTER }} \
            --services ${{ steps.env.outputs.SERVICE }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)

          if [ "$TARGET_GROUP" != "None" ] && [ -n "$TARGET_GROUP" ]; then
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns $TARGET_GROUP \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text)

            DNS_NAME=$(aws elbv2 describe-load-balancers \
              --load-balancer-arns $LB_ARN \
              --query 'LoadBalancers[0].DNSName' \
              --output text)

            echo "SERVICE_URL=http://${DNS_NAME}" >> $GITHUB_OUTPUT
            echo "service_url=http://${DNS_NAME}" >> $GITHUB_OUTPUT
          else
            echo "SERVICE_URL=N/A" >> $GITHUB_OUTPUT
            echo "service_url=N/A" >> $GITHUB_OUTPUT
          fi

      - name: Deployment summary
        run: |
          echo "âœ… Deployment successful!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Cluster: ${{ steps.env.outputs.CLUSTER }}"
          echo "Service: ${{ steps.env.outputs.SERVICE }}"
          echo "Task: ${{ steps.deploy.outputs.task-definition-arn }}"
          echo "URL: ${{ steps.url.outputs.SERVICE_URL }}"

  # ======================================
  # Job: Health Check
  # ======================================
  health-check:
    name: Post-Deploy Health Check
    runs-on: ubuntu-latest
    needs: deploy
    if: needs.deploy.result == 'success'
    steps:
      - name: Wait for service stabilization
        run: sleep 30

      - name: Health check
        id: health
        continue-on-error: true
        run: |
          URL="${{ needs.deploy.outputs.service_url }}/healthz"

          if [ "$URL" = "N/A/healthz" ]; then
            echo "âš ï¸ Service URL not available, skipping health check"
            exit 0
          fi

          MAX_RETRIES=5
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $URL || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Health check passed! (HTTP $HTTP_CODE)"
              exit 0
            else
              echo "âŒ Health check failed (HTTP $HTTP_CODE)"

              if [ $i -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            fi
          done

          echo "âŒ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Notify on failure
        if: failure()
        run: |
          echo "::warning::Health check failed after deployment"
          echo "::warning::Manual verification required"

  # ======================================
  # Job: Notification
  # ======================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [release, docker, deploy, health-check]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "STATUS=success" >> $GITHUB_OUTPUT
            echo "COLOR=good" >> $GITHUB_OUTPUT
            echo "EMOJI=âœ…" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" = "failure" ] || [ "${{ needs.docker.result }}" = "failure" ]; then
            echo "STATUS=failure" >> $GITHUB_OUTPUT
            echo "COLOR=danger" >> $GITHUB_OUTPUT
            echo "EMOJI=âŒ" >> $GITHUB_OUTPUT
          else
            echo "STATUS=warning" >> $GITHUB_OUTPUT
            echo "COLOR=warning" >> $GITHUB_OUTPUT
            echo "EMOJI=âš ï¸" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ${{ steps.status.outputs.EMOJI }} Deployment Summary

          **Branch**: `${{ github.ref_name }}`
          **Commit**: `${{ github.sha }}`
          **Environment**: `${{ github.ref == 'refs/heads/main' && 'production' || github.ref == 'refs/heads/develop' && 'staging' || 'homolog' }}`

          ### Results

          | Job | Status |
          |-----|--------|
          | Release | ${{ needs.release.result == 'success' && 'âœ…' || needs.release.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Docker Build | ${{ needs.docker.result == 'success' && 'âœ…' || needs.docker.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Deploy | ${{ needs.deploy.result == 'success' && 'âœ…' || needs.deploy.result == 'failure' && 'âŒ' || 'â­ï¸' }} |
          | Health Check | ${{ needs.health-check.result == 'success' && 'âœ…' || needs.health-check.result == 'failure' && 'âŒ' || 'â­ï¸' }} |

          ### Version Info

          - **Version**: ${{ needs.release.outputs.new_release_version || 'No new release' }}
          - **Docker Tag**: `${{ needs.docker.outputs.image_tag }}`
          - **Image Digest**: `${{ needs.docker.outputs.image_digest }}`

          ---

          **Workflow**: [${{ github.workflow }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
