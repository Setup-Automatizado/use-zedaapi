package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"image"
	"image/jpeg"
	"io"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/nfnt/resize"
	"github.com/rs/zerolog/log"
	"go.mau.fi/whatsmeow"
	"go.mau.fi/whatsmeow/proto/waE2E"
	"go.mau.fi/whatsmeow/types"

	"google.golang.org/protobuf/proto"
)

// SendDocument sends a document/attachment message to a recipient
//
//	@Summary		Send document message
//	@Description	Send a document or file attachment to a phone number or group. Supports various file types including PDF, Word, Excel, PowerPoint, ZIP, and more. The document can be sent as a base64 data URL or HTTP(S) URL. Supports captions, mentions, replies, forwarding, and ephemeral messages. Media is automatically processed and uploaded to configured S3 storage if available.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"	example("Z1234ABCCXD")
//	@Router			/chat/send/document [post]
func (s *server) SendDocument() http.HandlerFunc {

	type documentStruct struct {
		Caption     string
		Phone       string
		Document    string
		FileName    string
		Id          string
		MimeType    string
		Presence    *int    `json:"presence,omitempty"`
		Duration    *uint32 `json:"duration,omitempty"`
		NumberCheck *bool   `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo
		MentionInfo *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		DocumentAlt    string            `json:"Document,omitempty"`
		FileNameAlt    string            `json:"FileName,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		MimeTypeAlt    string            `json:"MimeType,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t documentStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Document == "" && t.DocumentAlt != "" {
			t.Document = t.DocumentAlt
		}
		if t.FileName == "" && t.FileNameAlt != "" {
			t.FileName = t.FileNameAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.MimeType == "" && t.MimeTypeAlt != "" {
			t.MimeType = t.MimeTypeAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Document == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Document in Payload"))
			return
		}

		if t.FileName == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing FileName in Payload"))
			return
		}

		config := &MediaMessageConfig{
			Phone:       t.Phone,
			MediaInput:  t.Document,
			Caption:     t.Caption,
			Id:          t.Id,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		mediaInfo, msgid, recipient, mentionedJIDs, isForwarded, err := s.processMediaMessage(txtid, config, whatsmeow.MediaDocument)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaDocument)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("failed to upload file: %v", err)))
			return
		}

		msg := &waE2E.Message{DocumentMessage: &waE2E.DocumentMessage{
			URL:        proto.String(uploaded.URL),
			FileName:   &t.FileName,
			DirectPath: proto.String(uploaded.DirectPath),
			MediaKey:   uploaded.MediaKey,
			Mimetype: proto.String(func() string {
				if t.MimeType != "" {
					return t.MimeType
				}
				return mediaInfo.MimeType
			}()),
			FileEncSHA256: uploaded.FileEncSHA256,
			FileSHA256:    uploaded.FileSHA256,
			FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
			Caption:       proto.String(t.Caption),
		}}

		finalMimeType := func() string {
			if t.MimeType != "" {
				return t.MimeType
			}
			return mediaInfo.MimeType
		}()
		ProcessDocument(msg, mediaInfo.Data, finalMimeType)

		if t.ContextInfo.StanzaID != nil {
			if msg.DocumentMessage.ContextInfo == nil {
				msg.DocumentMessage.ContextInfo = &waE2E.ContextInfo{
					StanzaID:      proto.String(*t.ContextInfo.StanzaID),
					Participant:   proto.String(*t.ContextInfo.Participant),
					QuotedMessage: getQuotedMessage(&t.ContextInfo),
				}
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.DocumentMessage.ContextInfo == nil {
				msg.DocumentMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.DocumentMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if len(mentionedJIDs) > 0 {
			addMentionsToMessage(msg, mentionedJIDs)
		}

		isForwarded = s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		baseConfig := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process document message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendAudio sends an audio message or voice note to a recipient
//
//	@Summary		Send audio message
//	@Description	Send an audio message or voice note to a WhatsApp contact or group. Supports various audio formats including MP3, OGG, AAC, and M4A. Can be sent as regular audio or PTT (Push To Talk) voice note. Audio can be provided as base64 data URL or HTTP(S) URL. Features include view-once messages, captions, replies, forwarding, and ephemeral messages. Audio is automatically processed and uploaded to configured S3 storage if available.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"	example("Z1234ABCDEF")
//	@Router			/chat/send/audio [post]
func (s *server) SendAudio() http.HandlerFunc {

	type audioStruct struct {
		Phone       string            `json:"phone,omitempty"`
		Audio       string            `json:"audio,omitempty"`
		Caption     string            `json:"caption,omitempty"`
		Id          string            `json:"id,omitempty"`
		PTT         *bool             `json:"ptt,omitempty"`
		Presence    *int              `json:"presence,omitempty"`
		ViewOnce    *bool             `json:"view_once,omitempty"`
		Duration    *uint32           `json:"duration,omitempty"`
		NumberCheck *bool             `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`
		MentionInfo *MentionInfo      `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo      `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		AudioAlt       string            `json:"Audio,omitempty"`
		CaptionAlt     string            `json:"Caption,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PTTAlt         *bool             `json:"PTT,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		ViewOnceAlt    *bool             `json:"ViewOnce,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		msgid := ""
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t audioStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Audio == "" && t.AudioAlt != "" {
			t.Audio = t.AudioAlt
		}
		if t.Caption == "" && t.CaptionAlt != "" {
			t.Caption = t.CaptionAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.PTT == nil && t.PTTAlt != nil {
			t.PTT = t.PTTAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.ViewOnce == nil && t.ViewOnceAlt != nil {
			t.ViewOnce = t.ViewOnceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Audio == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Audio in Payload"))
			return
		}

		config := &MediaMessageConfig{
			Phone:       t.Phone,
			MediaInput:  t.Audio,
			Caption:     t.Caption,
			Id:          t.Id,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		mediaInfo, msgid, recipient, mentionedJIDs, isForwarded, err := s.processMediaMessage(txtid, config, whatsmeow.MediaAudio)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		ptt := true
		if t.PTT != nil {
			ptt = *t.PTT
		}

		if ptt {
			if mediaInfo.MimeType == "" || !isValidAudioMimeType(mediaInfo.MimeType) ||
				mediaInfo.MimeType == "application/octet-stream" {
				mediaInfo.MimeType = "audio/ogg; codecs=opus"
				log.Debug().Str("final_mime", mediaInfo.MimeType).Msg("PTT=true: Using voice note optimized MIME type")
			}
		} else {
			if mediaInfo.MimeType == "application/octet-stream" {
				detectedMime, _ := DetectMimeTypeIntelligent(mediaInfo.Data, "", "")
				if detectedMime != "" && strings.HasPrefix(detectedMime, "audio/") && isValidAudioMimeType(detectedMime) {
					mediaInfo.MimeType = detectedMime
					log.Debug().Str("detected_mime", detectedMime).Msg("Audio MIME detected via smart detection")
				} else {
					mediaInfo.MimeType = "audio/mpeg"
				}
			} else if mediaInfo.MimeType != "" && !isValidAudioMimeType(mediaInfo.MimeType) {
				log.Warn().Str("mime_type", mediaInfo.MimeType).Msg("Non-standard audio MIME type, using default")
				mediaInfo.MimeType = "audio/mpeg"
			} else if mediaInfo.MimeType == "" {
				mediaInfo.MimeType = "audio/mpeg"
			}
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaAudio)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("failed to upload audio: %v", err)))
			return
		}

		audioOptions := AudioMessageOptions{
			Data:         mediaInfo.Data,
			MimeType:     mediaInfo.MimeType,
			PTT:          ptt,
			Duration:     0,
			GenerateWave: true,
			ViewOnce:     t.ViewOnce,
		}

		audioMsg := createAudioMessage(uploaded, audioOptions)
		msg := &waE2E.Message{AudioMessage: audioMsg}

		if t.ContextInfo.StanzaID != nil {
			msg.AudioMessage.ContextInfo = &waE2E.ContextInfo{
				StanzaID:      proto.String(*t.ContextInfo.StanzaID),
				Participant:   proto.String(*t.ContextInfo.Participant),
				QuotedMessage: getQuotedMessage(&t.ContextInfo),
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.AudioMessage.ContextInfo == nil {
				msg.AudioMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.AudioMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if len(mentionedJIDs) > 0 {
			addMentionsToMessage(msg, mentionedJIDs)
		}

		isForwarded = s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		baseConfig := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			ViewOnce:    t.ViewOnce,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, baseConfig, true)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process audio message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		if ptt {
			log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("VOICE NOTE sent (PTT=true)")
		} else {
			log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("AUDIO FILE sent (PTT=false)")
		}

		response := map[string]interface{}{
			"Details":   "Sent",
			"Timestamp": resp.Timestamp,
			"Id":        msgid,
			"Source":    string(mediaInfo.Source),
			"PTT":       ptt,
			"Type": func() string {
				if ptt {
					return "voice_note"
				}
				return "audio_file"
			}(),
			"Duration":    audioMsg.GetSeconds(),
			"HasWaveform": true,
			"MimeType":    mediaInfo.MimeType,
		}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

func isValidAudioMimeType(mimeType string) bool {
	validTypes := []string{
		"audio/ogg",
		"audio/oga",
		"audio/opus",
		"audio/x-m4b",
		"audio/x-m4p",
		"audio/x-m4r",
		"audio/ogg; codecs=opus",
		"audio/mpeg",
		"audio/mp3",
		"audio/aac",
		"audio/wav",
		"audio/webm",
		"audio/x-wav",
		"audio/x-m4a",
	}

	for _, valid := range validTypes {
		if mimeType == valid {
			return true
		}
	}
	return false
}

// SendImage sends an image message to a recipient
//
//	@Summary		Send image message
//	@Description	Send an image message to a WhatsApp contact or group. Supports JPEG, PNG, GIF, and WebP formats. Images can be sent as base64 data URLs or HTTP(S) URLs. Features include captions, view-once messages, mentions, replies, forwarding, and ephemeral messages. Large images are automatically compressed while maintaining quality. Images are automatically processed and uploaded to configured S3 storage if available.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"	example("Z1234ABCDEF")
//	@Router			/chat/send/image [post]
func (s *server) SendImage() http.HandlerFunc {

	type imageStruct struct {
		Phone       string            `json:"phone,omitempty"`
		Image       string            `json:"image,omitempty"`
		Caption     string            `json:"caption,omitempty"`
		Id          string            `json:"id,omitempty"`
		MimeType    string            `json:"mime_type,omitempty"`
		Presence    *int              `json:"presence,omitempty"`
		ViewOnce    *bool             `json:"view_once,omitempty"`
		Duration    *uint32           `json:"duration,omitempty"`
		NumberCheck *bool             `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`
		MentionInfo *MentionInfo      `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo      `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		ImageAlt       string            `json:"Image,omitempty"`
		CaptionAlt     string            `json:"Caption,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		MimeTypeAlt    string            `json:"MimeType,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		ViewOnceAlt    *bool             `json:"ViewOnce,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t imageStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Image == "" && t.ImageAlt != "" {
			t.Image = t.ImageAlt
		}
		if t.Caption == "" && t.CaptionAlt != "" {
			t.Caption = t.CaptionAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.MimeType == "" && t.MimeTypeAlt != "" {
			t.MimeType = t.MimeTypeAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.ViewOnce == nil && t.ViewOnceAlt != nil {
			t.ViewOnce = t.ViewOnceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Image == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Image in Payload"))
			return
		}

		config := &MediaMessageConfig{
			Phone:       t.Phone,
			MediaInput:  t.Image,
			Caption:     t.Caption,
			Id:          t.Id,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		mediaInfo, msgid, recipient, mentionedJIDs, isForwarded, err := s.processMediaMessage(txtid, config, whatsmeow.MediaImage)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		validImageMimes := []string{"image/jpeg", "image/png", "image/gif", "image/webp"}
		mimeValid := false
		for _, validMime := range validImageMimes {
			if mediaInfo.MimeType == validMime {
				mimeValid = true
				break
			}
		}
		if !mimeValid {
			s.Respond(w, r, http.StatusBadRequest, errors.New("invalid image format. Supported: JPEG, PNG, GIF, WebP"))
			return
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaImage)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("failed to upload file: %v", err)))
			return
		}

		var thumbnailBytes []byte
		reader := bytes.NewReader(mediaInfo.Data)
		img, _, err := image.Decode(reader)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("could not decode image for thumbnail preparation: %v", err)))
			return
		}

		m := resize.Thumbnail(72, 72, img, resize.Lanczos3)

		tmpFile, err := os.CreateTemp("", "resized-*.jpg")
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Could not create temp file for thumbnail: %v", err)))
			return
		}
		defer tmpFile.Close()
		defer os.Remove(tmpFile.Name())

		if err := jpeg.Encode(tmpFile, m, nil); err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Failed to encode jpeg: %v", err)))
			return
		}

		thumbnailBytes, err = os.ReadFile(tmpFile.Name())
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Failed to read %s: %v", tmpFile.Name(), err)))
			return
		}

		msg := &waE2E.Message{ImageMessage: &waE2E.ImageMessage{
			Caption:    proto.String(t.Caption),
			URL:        proto.String(uploaded.URL),
			DirectPath: proto.String(uploaded.DirectPath),
			MediaKey:   uploaded.MediaKey,
			Mimetype: proto.String(func() string {
				if t.MimeType != "" {
					return t.MimeType
				}
				return mediaInfo.MimeType
			}()),
			FileEncSHA256: uploaded.FileEncSHA256,
			FileSHA256:    uploaded.FileSHA256,
			FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
			JPEGThumbnail: thumbnailBytes,
			ViewOnce: proto.Bool(func() bool {
				if t.ViewOnce != nil {
					return *t.ViewOnce
				}
				return false
			}()),
		}}

		if t.ContextInfo.StanzaID != nil {
			if msg.ImageMessage.ContextInfo == nil {
				msg.ImageMessage.ContextInfo = &waE2E.ContextInfo{
					StanzaID:      proto.String(*t.ContextInfo.StanzaID),
					Participant:   proto.String(*t.ContextInfo.Participant),
					QuotedMessage: getQuotedMessage(&t.ContextInfo),
				}
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.ImageMessage.ContextInfo == nil {
				msg.ImageMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ImageMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if len(mentionedJIDs) > 0 {
			addMentionsToMessage(msg, mentionedJIDs)
		}

		isForwarded = s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		baseConfig := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			ViewOnce:    t.ViewOnce,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process image message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendSticker sends a sticker message to a recipient
//
//	@Summary		Send sticker message
//	@Description	Send a sticker message to a WhatsApp contact or group. Stickers must be in WebP format with maximum dimensions of 512x512 pixels. Animated stickers are supported. Stickers can be sent as base64 data URLs or HTTP(S) URLs. Features include replies, forwarding, and ephemeral messages. Stickers are automatically processed and uploaded to configured S3 storage if available.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"	example("Z1234ABCDEF")
//	@Router			/chat/send/sticker [post]
func (s *server) SendSticker() http.HandlerFunc {

	type stickerStruct struct {
		Phone        string
		Sticker      string
		Id           string
		PngThumbnail []byte
		MimeType     string
		Presence     *int  `json:"presence,omitempty"`
		NumberCheck  *bool `json:"number_check,omitempty"`
		ContextInfo  waE2E.ContextInfo
		MentionInfo  *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo  *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt        string            `json:"Phone,omitempty"`
		StickerAlt      string            `json:"Sticker,omitempty"`
		IdAlt           string            `json:"Id,omitempty"`
		PngThumbnailAlt []byte            `json:"PngThumbnail,omitempty"`
		MimeTypeAlt     string            `json:"MimeType,omitempty"`
		PresenceAlt     *int              `json:"Presence,omitempty"`
		NumberCheckAlt  *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt  waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t stickerStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Sticker == "" && t.StickerAlt != "" {
			t.Sticker = t.StickerAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if len(t.PngThumbnail) == 0 && len(t.PngThumbnailAlt) > 0 {
			t.PngThumbnail = t.PngThumbnailAlt
		}
		if t.MimeType == "" && t.MimeTypeAlt != "" {
			t.MimeType = t.MimeTypeAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Sticker == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Sticker in Payload"))
			return
		}

		config := &MediaMessageConfig{
			Phone:       t.Phone,
			MediaInput:  t.Sticker,
			Caption:     "",
			Id:          t.Id,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		mediaInfo, msgid, recipient, mentionedJIDs, isForwarded, err := s.processMediaMessage(txtid, config, whatsmeow.MediaImage)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		validStickerMimes := []string{"image/jpeg", "image/png", "image/gif", "image/webp"}
		mimeValid := false
		for _, validMime := range validStickerMimes {
			if mediaInfo.MimeType == validMime {
				mimeValid = true
				break
			}
		}
		if !mimeValid {
			s.Respond(w, r, http.StatusBadRequest, errors.New("invalid sticker format. Supported: JPEG, PNG, GIF, WebP"))
			return
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaImage)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Failed to upload file: %v", err)))
			return
		}

		msg := &waE2E.Message{StickerMessage: &waE2E.StickerMessage{
			URL:        proto.String(uploaded.URL),
			DirectPath: proto.String(uploaded.DirectPath),
			MediaKey:   uploaded.MediaKey,
			Mimetype: proto.String(func() string {
				if t.MimeType != "" {
					return t.MimeType
				}
				return mediaInfo.MimeType
			}()),
			FileEncSHA256: uploaded.FileEncSHA256,
			FileSHA256:    uploaded.FileSHA256,
			FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
			PngThumbnail:  t.PngThumbnail,
		}}

		if t.ContextInfo.StanzaID != nil {
			if msg.StickerMessage.ContextInfo == nil {
				msg.StickerMessage.ContextInfo = &waE2E.ContextInfo{
					StanzaID:      proto.String(*t.ContextInfo.StanzaID),
					Participant:   proto.String(*t.ContextInfo.Participant),
					QuotedMessage: getQuotedMessage(&t.ContextInfo),
				}
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.StickerMessage.ContextInfo == nil {
				msg.StickerMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.StickerMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if len(mentionedJIDs) > 0 {
			addMentionsToMessage(msg, mentionedJIDs)
		}

		isForwarded = s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		if t.Presence != nil && *t.Presence > 0 {
			err := processPresenceSimulation(client, recipient, t.Presence, false)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process presence simulation for sticker")
			}
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendVideo sends a video message to a recipient
//
//	@Summary		Send video message
//	@Description	Send a video message to a WhatsApp contact or group. Supports MP4, AVI, MOV, and other common video formats. Videos can be sent as base64 data URLs or HTTP(S) URLs. Features include captions, view-once messages, mentions, replies, forwarding, and ephemeral messages. Large videos are automatically optimized for WhatsApp delivery.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"
//	@Router			/chat/send/video [post]
func (s *server) SendVideo() http.HandlerFunc {

	type videoStruct struct {
		Phone         string            `json:"phone,omitempty"`
		Video         string            `json:"video,omitempty"`
		Caption       string            `json:"caption,omitempty"`
		Id            string            `json:"id,omitempty"`
		JPEGThumbnail []byte            `json:"jpeg_thumbnail,omitempty"`
		MimeType      string            `json:"mime_type,omitempty"`
		GIF           *bool             `json:"gif,omitempty"`
		Presence      *int              `json:"presence,omitempty"`
		ViewOnce      *bool             `json:"view_once,omitempty"`
		Duration      *uint32           `json:"duration,omitempty"`
		NumberCheck   *bool             `json:"number_check,omitempty"`
		ContextInfo   waE2E.ContextInfo `json:"context_info,omitempty"`
		MentionInfo   *MentionInfo      `json:"mention_info,omitempty"`
		ForwardInfo   *ForwardInfo      `json:"forward_info,omitempty"`

		PhoneAlt         string            `json:"Phone,omitempty"`
		VideoAlt         string            `json:"Video,omitempty"`
		CaptionAlt       string            `json:"Caption,omitempty"`
		IdAlt            string            `json:"Id,omitempty"`
		JPEGThumbnailAlt []byte            `json:"JPEGThumbnail,omitempty"`
		MimeTypeAlt      string            `json:"MimeType,omitempty"`
		GIFAlt           *bool             `json:"GIF,omitempty"`
		PresenceAlt      *int              `json:"Presence,omitempty"`
		ViewOnceAlt      *bool             `json:"ViewOnce,omitempty"`
		DurationAlt      *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt   *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt   waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t videoStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Video == "" && t.VideoAlt != "" {
			t.Video = t.VideoAlt
		}
		if t.Caption == "" && t.CaptionAlt != "" {
			t.Caption = t.CaptionAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if len(t.JPEGThumbnail) == 0 && len(t.JPEGThumbnailAlt) > 0 {
			t.JPEGThumbnail = t.JPEGThumbnailAlt
		}
		if t.MimeType == "" && t.MimeTypeAlt != "" {
			t.MimeType = t.MimeTypeAlt
		}
		if t.GIF == nil && t.GIFAlt != nil {
			t.GIF = t.GIFAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.ViewOnce == nil && t.ViewOnceAlt != nil {
			t.ViewOnce = t.ViewOnceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Video == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Video in Payload"))
			return
		}

		config := &MediaMessageConfig{
			Phone:       t.Phone,
			MediaInput:  t.Video,
			Caption:     t.Caption,
			Id:          t.Id,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		mediaInfo, msgid, recipient, mentionedJIDs, isForwarded, err := s.processMediaMessage(txtid, config, whatsmeow.MediaVideo)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		validVideoMimes := []string{"video/mp4", "video/3gpp", "video/quicktime", "video/x-ms-asf"}
		mimeValid := false
		for _, validMime := range validVideoMimes {
			if mediaInfo.MimeType == validMime {
				mimeValid = true
				break
			}
		}
		if !mimeValid {
			s.Respond(w, r, http.StatusBadRequest, errors.New("invalid video format. Supported: MP4, 3GP, MOV, ASF"))
			return
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaVideo)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("failed to upload file: %v", err)))
			return
		}

		var thumbnailBytes []byte
		if len(t.JPEGThumbnail) > 0 {
			thumbnailBytes = t.JPEGThumbnail
		} else {
			thumbnailBytes, err = GenerateJPEGThumbnailFromVideo(mediaInfo.Data)
			if err != nil {
				thumbnailBytes = generateDefaultVideoThumbnail()
			}
		}

		var durationSeconds uint32
		if mediaInfo.MimeType == "video/mp4" {
			durationSeconds = extractMP4Duration(mediaInfo.Data)
		}
		if t.GIF != nil && *t.GIF && durationSeconds > 6 {
			log.Warn().Uint32("video_seconds", durationSeconds).Msg("GIF requested with video > 6s; some clients may not display as GIF")
		}

		msg := &waE2E.Message{VideoMessage: &waE2E.VideoMessage{
			URL: proto.String(uploaded.URL),
			Mimetype: proto.String(func() string {
				if t.MimeType != "" {
					return t.MimeType
				}
				return mediaInfo.MimeType
			}()),
			Caption:       proto.String(t.Caption),
			FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
			FileSHA256:    uploaded.FileSHA256,
			FileEncSHA256: uploaded.FileEncSHA256,
			MediaKey:      uploaded.MediaKey,
			DirectPath:    proto.String(uploaded.DirectPath),
			Seconds: func() *uint32 {
				if durationSeconds > 0 {
					v := durationSeconds
					return &v
				}
				return nil
			}(),
			ViewOnce: proto.Bool(func() bool {
				if t.ViewOnce != nil {
					return *t.ViewOnce
				}
				return false
			}()),
			GifPlayback: proto.Bool(func() bool {
				if t.GIF != nil {
					return *t.GIF
				}
				return false
			}()),
			JPEGThumbnail:       thumbnailBytes,
			ThumbnailEncSHA256:  thumbnailBytes,
			ThumbnailSHA256:     thumbnailBytes,
			ThumbnailDirectPath: proto.String(uploaded.DirectPath),
		}}

		if t.ContextInfo.StanzaID != nil {
			if msg.VideoMessage.ContextInfo == nil {
				msg.VideoMessage.ContextInfo = &waE2E.ContextInfo{
					StanzaID:      proto.String(*t.ContextInfo.StanzaID),
					Participant:   proto.String(*t.ContextInfo.Participant),
					QuotedMessage: getQuotedMessage(&t.ContextInfo),
				}
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.VideoMessage.ContextInfo == nil {
				msg.VideoMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.VideoMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if len(mentionedJIDs) > 0 {
			addMentionsToMessage(msg, mentionedJIDs)
		}

		isForwarded = s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		baseConfig := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			ViewOnce:    t.ViewOnce,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process video message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendPTV sends a Pre-Recorded Transfer Video (PTV)
//
//	@Summary		Send PTV (Pre-Recorded Transfer Video)
//	@Description	Send a PTV by link or base64 (data URL). Only requires phone and video.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string					true	"User authentication token"
//	@Router			/chat/send/ptv [post]
func (s *server) SendPTV() http.HandlerFunc {
	type reqPTV struct {
		Phone string `json:"Phone"`
		Video string `json:"Video"`
	}
	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		var body reqPTV
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}
		if body.Phone == "" || body.Video == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing phone or video"))
			return
		}

		recipient, err := validateAndGetJID(txtid, body.Phone, nil, nil, nil)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		mediaInfo, err := processMediaInput(body.Video)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error processing video: %v", err))
			return
		}

		uploaded, err := client.Upload(context.Background(), mediaInfo.Data, whatsmeow.MediaVideo)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("error uploading video: %v", err))
			return
		}

		jpegThumb, _ := GenerateJPEGThumbnailFromVideo(mediaInfo.Data)

		vm := &waE2E.VideoMessage{
			URL:           proto.String(uploaded.URL),
			DirectPath:    proto.String(uploaded.DirectPath),
			MediaKey:      uploaded.MediaKey,
			FileSHA256:    uploaded.FileSHA256,
			FileEncSHA256: uploaded.FileEncSHA256,
			FileLength:    proto.Uint64(uploaded.FileLength),
			Mimetype:      proto.String(mediaInfo.MimeType),
			JPEGThumbnail: jpegThumb,
		}

		msg := &waE2E.Message{PtvMessage: vm}

		msgid := client.GenerateMessageID()
		resp, err := s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("Error sending ptv: %v", err))
			return
		}

		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, _ := json.Marshal(response)
		s.Respond(w, r, http.StatusOK, string(responseJson))
	}
}

// SendContact sends a contact message to a recipient
//
//	@Summary		Send contact message
//	@Description	Send a contact card (vCard) to a WhatsApp contact or group. The vCard can include phone numbers, email addresses, organization details, and more. Supports vCard 3.0 format. The contact will be displayed as an interactive card that recipients can save to their address book. Features include replies, forwarding, and ephemeral messages.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"
//	@Router			/chat/send/contact [post]
func (s *server) SendContact() http.HandlerFunc {

	type contactStruct struct {
		Phone       string
		Id          string
		Name        string
		Vcard       string
		Presence    *int    `json:"presence,omitempty"`
		Duration    *uint32 `json:"duration,omitempty"`
		NumberCheck *bool   `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo
		MentionInfo *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		NameAlt        string            `json:"Name,omitempty"`
		VcardAlt       string            `json:"Vcard,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		msgid := ""
		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t contactStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Name == "" && t.NameAlt != "" {
			t.Name = t.NameAlt
		}
		if t.Vcard == "" && t.VcardAlt != "" {
			t.Vcard = t.VcardAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}
		if t.Name == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Name in Payload"))
			return
		}
		if t.Vcard == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Vcard in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			log.Error().Msg(fmt.Sprintf("%s", err))
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		if t.Id == "" {
			msgid = client.GenerateMessageID()
		} else {
			msgid = t.Id
		}

		msg := &waE2E.Message{ContactMessage: &waE2E.ContactMessage{
			DisplayName: &t.Name,
			Vcard:       &t.Vcard,
		}}

		if t.ContextInfo.StanzaID != nil {
			msg.ContactMessage.ContextInfo = &waE2E.ContextInfo{
				StanzaID:      proto.String(*t.ContextInfo.StanzaID),
				Participant:   proto.String(*t.ContextInfo.Participant),
				QuotedMessage: getQuotedMessage(&t.ContextInfo),
			}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.ContactMessage.ContextInfo == nil {
				msg.ContactMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ContactMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		if t.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, t.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in contact message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(msg, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForward(t.ForwardInfo, &t.ContextInfo)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		if t.Presence != nil && *t.Presence > 0 {
			err := processPresenceSimulation(client, recipient, t.Presence, false)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process presence simulation for contact")
			}
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendLocation sends a location message to a recipient
//
//	@Summary		Send location message
//	@Description	Send a location message to a WhatsApp contact or group with GPS coordinates. You can optionally include a location name and address for better context. The location will be displayed as an interactive map in WhatsApp. Features include replies, forwarding, and ephemeral messages.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"
//	@Router			/chat/send/location [post]
func (s *server) SendLocation() http.HandlerFunc {

	type locationStruct struct {
		Phone       string
		Id          string
		Name        string
		Latitude    float64
		Longitude   float64
		Presence    *int    `json:"presence,omitempty"`
		Duration    *uint32 `json:"duration,omitempty"`
		NumberCheck *bool   `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo
		MentionInfo *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		NameAlt        string            `json:"Name,omitempty"`
		LatitudeAlt    float64           `json:"Latitude,omitempty"`
		LongitudeAlt   float64           `json:"Longitude,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		msgid := ""
		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t locationStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Name == "" && t.NameAlt != "" {
			t.Name = t.NameAlt
		}
		if t.Latitude == 0 && t.LatitudeAlt != 0 {
			t.Latitude = t.LatitudeAlt
		}
		if t.Longitude == 0 && t.LongitudeAlt != 0 {
			t.Longitude = t.LongitudeAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}
		if t.Latitude == 0 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Latitude in Payload"))
			return
		}
		if t.Longitude == 0 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Longitude in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			log.Error().Msg(fmt.Sprintf("%s", err))
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		if t.Id == "" {
			msgid = client.GenerateMessageID()
		} else {
			msgid = t.Id
		}

		msg := &waE2E.Message{LocationMessage: &waE2E.LocationMessage{
			DegreesLatitude:  &t.Latitude,
			DegreesLongitude: &t.Longitude,
			Name:             &t.Name,
		}}

		if t.ContextInfo.StanzaID != nil {
			msg.LocationMessage.ContextInfo = &waE2E.ContextInfo{
				StanzaID:      proto.String(*t.ContextInfo.StanzaID),
				Participant:   proto.String(*t.ContextInfo.Participant),
				QuotedMessage: getQuotedMessage(&t.ContextInfo),
			}
		}
		if t.ContextInfo.MentionedJID != nil {
			if msg.LocationMessage.ContextInfo == nil {
				msg.LocationMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.LocationMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		if t.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, t.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in location message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(msg, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForward(t.ForwardInfo, &t.ContextInfo)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		if t.Presence != nil && *t.Presence > 0 {
			err := processPresenceSimulation(client, recipient, t.Presence, false)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process presence simulation for location")
			}
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendMessage sends a text message to a recipient
//
//	@Summary		Send text message
//	@Description	Send a text message to a WhatsApp contact or group. Supports various features including link previews, mentions, replies, forwarding, typing simulation, and ephemeral messages. The message can include up to 4096 characters and supports Unicode, emojis, and formatting.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string					true	"User authentication token"
//	@Router			/chat/send/text [post]
func (s *server) SendMessage() http.HandlerFunc {

	type textStruct struct {
		Phone       string            `json:"phone,omitempty"`
		Body        string            `json:"body,omitempty"`
		Id          string            `json:"id,omitempty"`
		Presence    *int              `json:"presence,omitempty"`
		LinkPreview *bool             `json:"link_preview,omitempty"`
		Duration    *uint32           `json:"duration,omitempty"`
		NumberCheck *bool             `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`
		MentionInfo *MentionInfo      `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo      `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		BodyAlt        string            `json:"Body,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		LinkPreviewAlt *bool             `json:"LinkPreview,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		msgid := ""
		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t textStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Body == "" && t.BodyAlt != "" {
			t.Body = t.BodyAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.LinkPreview == nil && t.LinkPreviewAlt != nil {
			t.LinkPreview = t.LinkPreviewAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Body == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Body in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			log.Error().Msg(fmt.Sprintf("%s", err))
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		if t.Id == "" {
			msgid = clientManager.GetWhatsmeowClient(txtid).GenerateMessageID()
		} else {
			msgid = t.Id
		}

		msg := &waE2E.Message{
			ExtendedTextMessage: &waE2E.ExtendedTextMessage{
				Text: &t.Body,
			},
		}

		if t.ContextInfo.StanzaID != nil {
			msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{
				StanzaID:      proto.String(*t.ContextInfo.StanzaID),
				Participant:   proto.String(*t.ContextInfo.Participant),
				QuotedMessage: getQuotedMessage(&t.ContextInfo),
			}
		}
		if t.ContextInfo.MentionedJID != nil {
			if msg.ExtendedTextMessage.ContextInfo == nil {
				msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ExtendedTextMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		if t.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, t.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in text message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(msg, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForwardWithJSON(t.ForwardInfo, &t.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		if t.LinkPreview != nil && *t.LinkPreview {
			links := extractLinksFromText(t.Body)
			if len(links) > 0 {
				_ = processLinkPreviewClean(client, recipient, msg, links[0], t.LinkPreview)
			}
		}

		config := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			LinkPreview: t.LinkPreview,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, config, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}

		return
	}
}

// SendPoll sends a poll message to a recipient
//
//	@Summary		Send poll message
//	@Description	Send a poll with multiple choice options to a WhatsApp group or contact. Polls allow recipients to vote on options you provide. You can create polls with 2-12 options, and optionally allow multiple selections. Poll results are visible to all participants in real-time. Note: Polls are primarily designed for group chats.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string					true	"User authentication token"
//	@Router			/chat/send/poll [post]
func (s *server) SendPoll() http.HandlerFunc {
	type pollRequest struct {
		Group       string            `json:"group,omitempty"`
		Phone       string            `json:"phone,omitempty"`
		Header      string            `json:"header"`
		Question    string            `json:"question,omitempty"`
		Options     []string          `json:"options"`
		MaxAnswer   *int              `json:"max_answer,omitempty"`
		Id          string            `json:"id,omitempty"`
		Presence    *int              `json:"presence,omitempty"`
		Duration    *uint32           `json:"duration,omitempty"`
		NumberCheck *bool             `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`
		MentionInfo *MentionInfo      `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo      `json:"forward_info,omitempty"`

		GroupAlt       string            `json:"Group,omitempty"`
		PhoneAlt       string            `json:"Phone,omitempty"`
		HeaderAlt      string            `json:"Header,omitempty"`
		QuestionAlt    string            `json:"Question,omitempty"`
		OptionsAlt     []string          `json:"Options,omitempty"`
		MaxAnswerAlt   *int              `json:"MaxAnswer,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		msgid := ""
		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var req pollRequest
		err = decoder.Decode(&req)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode payload"))
			return
		}

		if req.Group == "" && req.GroupAlt != "" {
			req.Group = req.GroupAlt
		}
		if req.Phone == "" && req.PhoneAlt != "" {
			req.Phone = req.PhoneAlt
		}
		if req.Header == "" && req.HeaderAlt != "" {
			req.Header = req.HeaderAlt
		}
		if req.Question == "" && req.QuestionAlt != "" {
			req.Question = req.QuestionAlt
		}
		if req.Options == nil && req.OptionsAlt != nil {
			req.Options = req.OptionsAlt
		}
		if req.MaxAnswer == nil && req.MaxAnswerAlt != nil {
			req.MaxAnswer = req.MaxAnswerAlt
		}
		if req.Id == "" && req.IdAlt != "" {
			req.Id = req.IdAlt
		}
		if req.Presence == nil && req.PresenceAlt != nil {
			req.Presence = req.PresenceAlt
		}
		if req.Duration == nil && req.DurationAlt != nil {
			req.Duration = req.DurationAlt
		}
		if req.NumberCheck == nil && req.NumberCheckAlt != nil {
			req.NumberCheck = req.NumberCheckAlt
		}
		if req.ContextInfo.StanzaID == nil && req.ContextInfoAlt.StanzaID != nil {
			req.ContextInfo = req.ContextInfoAlt
		}

		if req.Group == "" && req.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Group or Phone in payload"))
			return
		}

		if req.Header == "" && req.Question == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Header or Question in payload"))
			return
		}

		if len(req.Options) < 2 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("at least 2 options are required"))
			return
		}

		maxAns := 1
		if req.MaxAnswer != nil {
			maxAns = *req.MaxAnswer
		}
		if maxAns < 1 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("max_answer must be at least 1"))
			return
		}
		if maxAns > len(req.Options) {
			s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("max_answer cannot be greater than options length (%d)", len(req.Options)))
			return
		}

		if req.Id == "" {
			msgid = clientManager.GetWhatsmeowClient(txtid).GenerateMessageID()
		} else {
			msgid = req.Id
		}

		phoneToValidate := req.Phone
		if req.Group != "" {
			phoneToValidate = req.Group
		}

		QuestionToValidate := req.Question
		if req.Header != "" {
			QuestionToValidate = req.Header
		}

		recipient, err := validateAndGetJID(txtid, phoneToValidate, req.NumberCheck, req.ContextInfo.StanzaID, req.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		pollMessage := clientManager.GetWhatsmeowClient(txtid).BuildPollCreation(QuestionToValidate, req.Options, maxAns)

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &req.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(pollMessage, contextMentions)
		}

		if req.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, req.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in poll message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(pollMessage, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForwardWithJSON(req.ForwardInfo, &req.ContextInfo, bodyBytes)
		if isForwarded {
			addForwardToMessage(pollMessage, isForwarded)
		}

		resp, err = s.sendMessageWithEchoByID(context.Background(), txtid, recipient, pollMessage, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("failed to send poll: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Poll sent")

		response := map[string]interface{}{"Details": "Poll sent successfully", "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
	}
}

// SendEditMessage sends an edited text message to a recipient
//
//	@Summary		Send edited text message
//	@Description	Send an edited text message to a phone number or group. Supports mentions, replies, forwarding, and various message enhancements.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string					true	"User authentication token"
//	@Router			/chat/send/edit [post]
func (s *server) SendEditMessage() http.HandlerFunc {

	type editStruct struct {
		Phone       string
		Body        string
		Id          string
		MessageID   string  `json:"message_id,omitempty"`
		Presence    *int    `json:"presence,omitempty"`
		LinkPreview *bool   `json:"link_preview,omitempty"`
		Duration    *uint32 `json:"duration,omitempty"`
		NumberCheck *bool   `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo
		MentionInfo *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		BodyAlt        string            `json:"Body,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		MessageIDAlt   string            `json:"MessageID,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		LinkPreviewAlt *bool             `json:"LinkPreview,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		msgid := ""
		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t editStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Body == "" && t.BodyAlt != "" {
			t.Body = t.BodyAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.MessageID == "" && t.MessageIDAlt != "" {
			t.MessageID = t.MessageIDAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.LinkPreview == nil && t.LinkPreviewAlt != nil {
			t.LinkPreview = t.LinkPreviewAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if t.Body == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Body in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			log.Error().Msg(fmt.Sprintf("%s", err))
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		if t.Id == "" && t.MessageID == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Id or MessageID in Payload"))
			return
		}
		if t.Id != "" {
			msgid = t.Id
		}
		if t.MessageID != "" {
			msgid = t.MessageID
		}

		msg := &waE2E.Message{
			ExtendedTextMessage: &waE2E.ExtendedTextMessage{
				Text: &t.Body,
			},
		}

		if t.ContextInfo.StanzaID != nil {
			msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{
				StanzaID:      proto.String(*t.ContextInfo.StanzaID),
				Participant:   proto.String(*t.ContextInfo.Participant),
				QuotedMessage: getQuotedMessage(&t.ContextInfo),
			}
		}
		if t.ContextInfo.MentionedJID != nil {
			if msg.ExtendedTextMessage.ContextInfo == nil {
				msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ExtendedTextMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		if t.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, t.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in edit message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(msg, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForward(t.ForwardInfo, &t.ContextInfo)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		if t.Presence != nil && *t.Presence > 0 {
			err := processPresenceSimulation(client, recipient, t.Presence, false)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process presence simulation for edit")
			}
		}

		if t.LinkPreview != nil && *t.LinkPreview {
			links := extractLinksFromText(t.Body)
			if len(links) > 0 {
				_ = processLinkPreviewClean(client, recipient, msg, links[0], t.LinkPreview)
			}
		}

		edited := client.BuildEdit(recipient, msgid, msg)
		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, edited, whatsmeow.SendRequestExtra{}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending edit message: %v", err)))
			return
		}

		log.Info().Str("timestamp", resp.Timestamp.Format(time.RFC3339)).Str("id", msgid).Msg("Message edit sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}

		return
	}
}

// SendLink sends a text message with automatic link preview from metadata
//
//	@Summary		Send link message with automatic preview
//	@Description	Send a text message with an automatic link preview from metadata. Supports captions, mentions, replies, and forwarding.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string					true	"User authentication token"
//	@Router			/chat/send/link [post]
func (s *server) SendLink() http.HandlerFunc {
	type linkStruct struct {
		Phone       string  `json:"phone"`
		Link        string  `json:"link"`
		Caption     string  `json:"caption,omitempty"`
		Id          string  `json:"id,omitempty"`
		Presence    *int    `json:"presence,omitempty"`
		Duration    *uint32 `json:"duration,omitempty"`
		NumberCheck *bool   `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo
		MentionInfo *MentionInfo `json:"mention_info,omitempty"`
		ForwardInfo *ForwardInfo `json:"forward_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		LinkAlt        string            `json:"Link,omitempty"`
		CaptionAlt     string            `json:"Caption,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t linkStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Link == "" && t.LinkAlt != "" {
			t.Link = t.LinkAlt
		}
		if t.Caption == "" && t.CaptionAlt != "" {
			t.Caption = t.CaptionAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in payload"))
			return
		}

		if t.Link == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Link in payload"))
			return
		}

		if !strings.HasPrefix(t.Link, "http://") && !strings.HasPrefix(t.Link, "https://") {
			s.Respond(w, r, http.StatusBadRequest, errors.New("invalid URL format"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		msgid := ""
		if t.Id == "" {
			msgid = client.GenerateMessageID()
		} else {
			msgid = t.Id
		}

		metadata, err := getMetadataFromURLClean(t.Link)
		if err != nil {
			log.Warn().Err(err).Str("link", t.Link).Msg("Failed to extract link metadata")
		}

		var messageText string
		if t.Caption != "" {
			messageText = fmt.Sprintf("%s\n%s", t.Caption, t.Link)
		} else {
			messageText = t.Link
		}

		msg := &waE2E.Message{
			ExtendedTextMessage: &waE2E.ExtendedTextMessage{
				Text: proto.String(messageText),
			},
		}

		linkPreviewEnabled := true
		_ = processLinkPreviewClean(client, recipient, msg, t.Link, &linkPreviewEnabled)

		if t.ContextInfo.StanzaID != nil {
			if msg.ExtendedTextMessage.ContextInfo == nil {
				msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ExtendedTextMessage.ContextInfo.StanzaID = proto.String(*t.ContextInfo.StanzaID)
			msg.ExtendedTextMessage.ContextInfo.Participant = proto.String(*t.ContextInfo.Participant)
			msg.ExtendedTextMessage.ContextInfo.QuotedMessage = &waE2E.Message{Conversation: proto.String("")}
		}

		if t.ContextInfo.MentionedJID != nil {
			if msg.ExtendedTextMessage.ContextInfo == nil {
				msg.ExtendedTextMessage.ContextInfo = &waE2E.ContextInfo{}
			}
			msg.ExtendedTextMessage.ContextInfo.MentionedJID = t.ContextInfo.MentionedJID
		}

		if t.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, t.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in link message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(msg, mentionedJIDs)
			}
		}

		isForwarded := s.processUniversalForward(t.ForwardInfo, &t.ContextInfo)
		if isForwarded {
			addForwardToMessage(msg, isForwarded)
		}

		config := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			LinkPreview: nil,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
			MentionInfo: t.MentionInfo,
			ForwardInfo: t.ForwardInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, config, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process link message enhancements")
		}

		resp, err = s.sendMessageWithEchoByID(context.Background(), txtid, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("error sending link message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Str("link", t.Link).Msg("Link message sent")
		response := map[string]interface{}{
			"Details":   "Link message sent successfully",
			"Timestamp": resp.Timestamp,
			"Id":        msgid,
			"Link":      t.Link,
			"Metadata": map[string]interface{}{
				"Title":       metadata.Title,
				"Description": metadata.Description,
				"Image":       metadata.Image,
			},
		}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
		return
	}
}

// SendButtonsMessage sends a message with interactive buttons to a recipient (individual or group)
//
//	@Summary		Send buttons message
//	@Description	Send a message with interactive buttons to a phone number or group. This endpoint supports multiple button types including quick replies, URL links, phone calls, copy actions, and payment integrations (PIX). The message can include media attachments (images, videos, documents) and supports all message enhancements like mentions, replies, and forwarding.
//
// **TYPES OF BUTTONS AVAILABLE:**
//
// 1. **Quick Reply Button** (`"quick_reply"`)
//   - Simple text response button
//   - Parameters: `text` (display text), `id` (button identifier)
//   - Use case: Simple responses, surveys, confirmations
//
// 2. **URL Button** (`"cta_url"`)
//   - Opens a web link when clicked
//   - Parameters: `text` (display text), `url` (web link)
//   - Use case: Website links, documentation, external resources
//
// 3. **Phone Call Button** (`"cta_call"`)
//   - Initiates a phone call when clicked
//   - Parameters: `text` (display text), `phone` (phone number)
//   - Use case: Customer support, direct contact
//
// 4. **Copy Button** (`"cta_copy"`)
//   - Copies text to clipboard when clicked
//   - Parameters: `text` (display text), `code` (text to copy)
//   - Use case: Coupon codes, reference numbers, access codes
//
// 5. **PIX Payment Button** (`"payment_info"`)
//   - Brazilian PIX payment integration
//   - Parameters: `pix_key`, `merchant_name`, `pix_type` (CPF, CNPJ, email, phone, random)
//   - Use case: Payment processing, e-commerce
//
// 6. **Review and Pay Button** (`"review_and_pay"`)
//   - Advanced payment with order review
//   - Parameters: `pix_key`, `merchant_name`, `pix_type`, order details
//   - Use case: Complex payment flows, order confirmation
//
// **MEDIA SUPPORT:**
// - Images: JPEG, PNG, GIF (max 5MB)
// - Videos: MP4, MOV, AVI (max 16MB)
// - Documents: PDF, DOC, XLS, etc. (max 100MB)
//
// **MESSAGE ENHANCEMENTS:**
// - Mentions: Tag specific users in groups
// - Replies: Respond to specific messages
// - Forwarding: Forward message with context
// - Presence: Simulate typing indicators
// - Expiration: Set message expiration time
//
// **COMPATIBILITY:**
//   - Supports both snake_case and PascalCase field names
//   - Automatic field normalization for maximum compatibility
//
// SendButtonsMessage sends an interactive message with action buttons
//
//	@Summary		Send buttons message
//	@Description	Send interactive message with up to 3 action buttons to a WhatsApp contact or group. Supports reply buttons, URL buttons, phone buttons, and PIX payment buttons. Can include optional media attachment (image, video, or document). Features include custom titles, footers, and ephemeral messages.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"
//	@Router			/chat/send/buttons [post]
func (s *server) SendButtonsMessage() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		type Media struct {
			URL      string `json:"url"`
			Filename string `json:"filename,omitempty"`
		}

		type ButtonText struct {
			DisplayText    string `json:"displayText"`
			DisplayTextAlt string `json:"DisplayText,omitempty"`
		}

		type ButtonReviewItem struct {
			Name            string `json:"name"`
			NameAlt         string `json:"Name,omitempty"`
			Quantity        int    `json:"quantity"`
			QuantityAlt     *int   `json:"Quantity,omitempty"`
			AmountValue     int    `json:"amount_value"`
			AmountValueAlt  *int   `json:"AmountValue,omitempty"`
			AmountOffset    int    `json:"amount_offset"`
			AmountOffsetAlt *int   `json:"AmountOffset,omitempty"`
		}

		type Button struct {
			ButtonID        string             `json:"buttonId"`
			ButtonIDAlt     string             `json:"ButtonId,omitempty"`
			ButtonText      ButtonText         `json:"buttonText"`
			ButtonTextAlt   *ButtonText        `json:"ButtonText,omitempty"`
			Type            string             `json:"type"`
			TypeAlt         string             `json:"Type,omitempty"`
			URL             string             `json:"url,omitempty"`
			URLAlt          string             `json:"Url,omitempty"`
			MerchantURL     string             `json:"merchant_url,omitempty"`
			MerchantURLAlt  string             `json:"MerchantUrl,omitempty"`
			Code            string             `json:"code,omitempty"`
			CodeAlt         string             `json:"Code,omitempty"`
			Phone           string             `json:"phone,omitempty"`
			PhoneAlt        string             `json:"Phone,omitempty"`
			PixKey          string             `json:"pix_key,omitempty"`
			PixKeyAlt       string             `json:"PixKey,omitempty"`
			MerchantName    string             `json:"merchant_name,omitempty"`
			MerchantNameAlt string             `json:"MerchantName,omitempty"`
			PixType         string             `json:"pix_type,omitempty"`
			PixTypeAlt      string             `json:"PixType,omitempty"`
			Currency        string             `json:"currency,omitempty"`
			CurrencyAlt     string             `json:"Currency,omitempty"`
			TotalValue      *int               `json:"total_value,omitempty"`
			TotalValueAlt   *int               `json:"TotalValue,omitempty"`
			TotalOffset     *int               `json:"total_offset,omitempty"`
			TotalOffsetAlt  *int               `json:"TotalOffset,omitempty"`
			ReferenceID     string             `json:"reference_id,omitempty"`
			ReferenceIDAlt  string             `json:"ReferenceId,omitempty"`
			Items           []ButtonReviewItem `json:"items,omitempty"`
			ItemsAlt        []ButtonReviewItem `json:"Items,omitempty"`
		}

		type ButtonsMessage struct {
			Phone       string            `json:"phone"`
			Image       *Media            `json:"image,omitempty"`
			Video       *Media            `json:"video,omitempty"`
			Document    *Media            `json:"document,omitempty"`
			Caption     string            `json:"caption"`
			Buttons     []Button          `json:"buttons"`
			Title       string            `json:"title"`
			Footer      string            `json:"footer,omitempty"`
			Body        string            `json:"body,omitempty"`
			Text        string            `json:"text,omitempty"`
			Id          string            `json:"id,omitempty"`
			Presence    *int              `json:"presence,omitempty"`
			Duration    *uint32           `json:"duration,omitempty"`
			NumberCheck *bool             `json:"number_check,omitempty"`
			ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`

			PhoneAlt       string            `json:"Phone,omitempty"`
			ImageAlt       *Media            `json:"Image,omitempty"`
			VideoAlt       *Media            `json:"Video,omitempty"`
			DocumentAlt    *Media            `json:"Document,omitempty"`
			CaptionAlt     string            `json:"Caption,omitempty"`
			ButtonsAlt     []Button          `json:"Buttons,omitempty"`
			TitleAlt       string            `json:"Title,omitempty"`
			FooterAlt      string            `json:"Footer,omitempty"`
			BodyAlt        string            `json:"Body,omitempty"`
			TextAlt        string            `json:"Text,omitempty"`
			IdAlt          string            `json:"Id,omitempty"`
			PresenceAlt    *int              `json:"Presence,omitempty"`
			DurationAlt    *uint32           `json:"Duration,omitempty"`
			NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
			ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
		}

		normalizeButtonText := func(btnText *ButtonText) {
			if btnText == nil {
				return
			}
			if btnText.DisplayText == "" && btnText.DisplayTextAlt != "" {
				btnText.DisplayText = btnText.DisplayTextAlt
			}
		}

		normalizeReviewItem := func(item *ButtonReviewItem) {
			if item == nil {
				return
			}
			if item.Name == "" && item.NameAlt != "" {
				item.Name = item.NameAlt
			}
			if item.Quantity == 0 && item.QuantityAlt != nil {
				item.Quantity = *item.QuantityAlt
			}
			if item.AmountValue == 0 && item.AmountValueAlt != nil {
				item.AmountValue = *item.AmountValueAlt
			}
			if item.AmountOffset == 0 && item.AmountOffsetAlt != nil {
				item.AmountOffset = *item.AmountOffsetAlt
			}
		}

		normalizeButton := func(btn *Button) {
			if btn == nil {
				return
			}
			if btn.ButtonID == "" && btn.ButtonIDAlt != "" {
				btn.ButtonID = btn.ButtonIDAlt
			}
			if btn.ButtonText.DisplayText == "" && btn.ButtonTextAlt != nil && btn.ButtonTextAlt.DisplayText != "" {
				btn.ButtonText = *btn.ButtonTextAlt
			}
			normalizeButtonText(&btn.ButtonText)
			if btn.Type == "" && btn.TypeAlt != "" {
				btn.Type = btn.TypeAlt
			}
			if btn.URL == "" && btn.URLAlt != "" {
				btn.URL = btn.URLAlt
			}
			if btn.MerchantURL == "" && btn.MerchantURLAlt != "" {
				btn.MerchantURL = btn.MerchantURLAlt
			}
			if btn.Code == "" && btn.CodeAlt != "" {
				btn.Code = btn.CodeAlt
			}
			if btn.Phone == "" && btn.PhoneAlt != "" {
				btn.Phone = btn.PhoneAlt
			}
			if btn.PixKey == "" && btn.PixKeyAlt != "" {
				btn.PixKey = btn.PixKeyAlt
			}
			if btn.MerchantName == "" && btn.MerchantNameAlt != "" {
				btn.MerchantName = btn.MerchantNameAlt
			}
			if btn.PixType == "" && btn.PixTypeAlt != "" {
				btn.PixType = btn.PixTypeAlt
			}
			if btn.Currency == "" && btn.CurrencyAlt != "" {
				btn.Currency = btn.CurrencyAlt
			}
			if btn.TotalValue == nil && btn.TotalValueAlt != nil {
				btn.TotalValue = btn.TotalValueAlt
			}
			if btn.TotalOffset == nil && btn.TotalOffsetAlt != nil {
				btn.TotalOffset = btn.TotalOffsetAlt
			}
			if btn.ReferenceID == "" && btn.ReferenceIDAlt != "" {
				btn.ReferenceID = btn.ReferenceIDAlt
			}
			if len(btn.Items) == 0 && len(btn.ItemsAlt) > 0 {
				btn.Items = btn.ItemsAlt
			}
			for i := range btn.Items {
				normalizeReviewItem(&btn.Items[i])
			}
		}

		var buttonsMessage ButtonsMessage
		decoder := json.NewDecoder(r.Body)
		err = decoder.Decode(&buttonsMessage)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if buttonsMessage.Phone == "" && buttonsMessage.PhoneAlt != "" {
			buttonsMessage.Phone = buttonsMessage.PhoneAlt
		}
		if buttonsMessage.Image == nil && buttonsMessage.ImageAlt != nil {
			buttonsMessage.Image = buttonsMessage.ImageAlt
		}
		if buttonsMessage.Video == nil && buttonsMessage.VideoAlt != nil {
			buttonsMessage.Video = buttonsMessage.VideoAlt
		}
		if buttonsMessage.Document == nil && buttonsMessage.DocumentAlt != nil {
			buttonsMessage.Document = buttonsMessage.DocumentAlt
		}
		if buttonsMessage.Caption == "" && buttonsMessage.CaptionAlt != "" {
			buttonsMessage.Caption = buttonsMessage.CaptionAlt
		}
		if buttonsMessage.Buttons == nil && buttonsMessage.ButtonsAlt != nil {
			buttonsMessage.Buttons = buttonsMessage.ButtonsAlt
		}
		if buttonsMessage.Title == "" && buttonsMessage.TitleAlt != "" {
			buttonsMessage.Title = buttonsMessage.TitleAlt
		}
		if buttonsMessage.Footer == "" && buttonsMessage.FooterAlt != "" {
			buttonsMessage.Footer = buttonsMessage.FooterAlt
		}
		if buttonsMessage.Body == "" && buttonsMessage.BodyAlt != "" {
			buttonsMessage.Body = buttonsMessage.BodyAlt
		}
		if buttonsMessage.Text == "" && buttonsMessage.TextAlt != "" {
			buttonsMessage.Text = buttonsMessage.TextAlt
		}
		if buttonsMessage.Text == "" && buttonsMessage.Body != "" {
			buttonsMessage.Text = buttonsMessage.Body
		}
		if buttonsMessage.Body == "" && buttonsMessage.Text != "" {
			buttonsMessage.Body = buttonsMessage.Text
		}
		if buttonsMessage.Id == "" && buttonsMessage.IdAlt != "" {
			buttonsMessage.Id = buttonsMessage.IdAlt
		}
		if buttonsMessage.Presence == nil && buttonsMessage.PresenceAlt != nil {
			buttonsMessage.Presence = buttonsMessage.PresenceAlt
		}
		if buttonsMessage.Duration == nil && buttonsMessage.DurationAlt != nil {
			buttonsMessage.Duration = buttonsMessage.DurationAlt
		}
		if buttonsMessage.NumberCheck == nil && buttonsMessage.NumberCheckAlt != nil {
			buttonsMessage.NumberCheck = buttonsMessage.NumberCheckAlt
		}
		if buttonsMessage.ContextInfo.StanzaID == nil && buttonsMessage.ContextInfoAlt.StanzaID != nil {
			buttonsMessage.ContextInfo = buttonsMessage.ContextInfoAlt
		}

		for i := range buttonsMessage.Buttons {
			normalizeButton(&buttonsMessage.Buttons[i])
		}

		if buttonsMessage.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, buttonsMessage.Phone, buttonsMessage.NumberCheck, buttonsMessage.ContextInfo.StanzaID, buttonsMessage.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		hasMedia := buttonsMessage.Image != nil || buttonsMessage.Video != nil || buttonsMessage.Document != nil

		buttonFactory := ButtonFactory{}
		messageFactory := ButtonMessageFactory{}

		mapButtonType := func(btn Button) (ButtonType, error) {
			if btn.Type != "" {
				switch btn.Type {
				case "reply", "quick_reply":
					return ButtonReply, nil
				case "url", "cta_url":
					return ButtonURL, nil
				case "copy", "cta_copy":
					return ButtonCopy, nil
				case "phone", "call", "cta_call":
					return ButtonPhone, nil
				case "pix", "payment_info":
					return ButtonPix, nil
				case "review_and_pay":
					return ButtonReviewAndPay, nil
				default:
					return "", fmt.Errorf("button type not found: %s", btn.Type)
				}
			}

			return "", fmt.Errorf("button type not specified")
		}

		var waButtons []*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton
		for _, btn := range buttonsMessage.Buttons {

			var waButton *waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton
			buttonType, err := mapButtonType(btn)
			if err != nil {
				log.Error().Err(err).Str("button_type", btn.Type).Msg("DEBUG: Invalid button type")
				s.Respond(w, r, http.StatusBadRequest, err)
				return
			}

			switch buttonType {
			case ButtonReply:
				waButton, err = buttonFactory.NewReplyBtn(btn.ButtonText.DisplayText, btn.ButtonID)
			case ButtonURL:
				waButton, err = buttonFactory.NewUrlBtn(btn.ButtonText.DisplayText, btn.URL)
			case ButtonCopy:
				waButton, err = buttonFactory.NewCopyBtn(btn.ButtonText.DisplayText, btn.Code)
			case ButtonPhone:
				waButton, err = buttonFactory.NewCallBtn(btn.ButtonText.DisplayText, btn.Phone)
			case ButtonPix:
				pixKey := btn.PixKey
				merchantName := btn.MerchantName
				pixType := btn.PixType

				if pixKey == "" {
					pixKey = "pix_key_required"
				}
				if merchantName == "" {
					merchantName = "Merchant"
				}
				if pixType == "" {
					pixType = "PHONE"
				}

				waButton, err = buttonFactory.NewPixBtn(pixKey, merchantName, pixType)
			case ButtonReviewAndPay:
				cfg := ReviewAndPayConfig{
					PixKey:       firstNonEmpty(btn.PixKey, "pix_key_required"),
					MerchantName: firstNonEmpty(btn.MerchantName, "Merchant"),
					PixKind:      firstNonEmpty(btn.PixType, "PHONE"),
					Currency:     firstNonEmpty(btn.Currency, "BRL"),
					ReferenceID:  btn.ReferenceID,
				}
				if btn.TotalValue != nil {
					cfg.TotalValue = *btn.TotalValue
				}
				if btn.TotalOffset != nil {
					cfg.TotalOffset = *btn.TotalOffset
				}
				for _, it := range btn.Items {
					cfg.Items = append(cfg.Items, ReviewAndPayItemInput{
						Name:         it.Name,
						Quantity:     it.Quantity,
						AmountValue:  it.AmountValue,
						AmountOffset: it.AmountOffset,
					})
				}
				waButton, err = buttonFactory.NewReviewPayBtnCustom(cfg)
			default:
				err = fmt.Errorf("button type not found: %s", btn.Type)
			}

			if err != nil {
				log.Error().Err(err).Str("button_type", string(buttonType)).Msg("DEBUG: Failed to create button")
				s.Respond(w, r, http.StatusBadRequest, err)
				return
			}

			waButtons = append(waButtons, waButton)
		}

		var headerMedia *HeaderMedia
		var headerMediaInfo *MediaInfo
		var headerMediaType whatsmeow.MediaType
		headerMediaMime := ""
		if hasMedia {
			var mediaURL string
			if buttonsMessage.Image != nil {
				mediaURL = buttonsMessage.Image.URL
				headerMediaType = whatsmeow.MediaImage
			} else if buttonsMessage.Video != nil {
				mediaURL = buttonsMessage.Video.URL
				headerMediaType = whatsmeow.MediaVideo
			} else if buttonsMessage.Document != nil {
				mediaURL = buttonsMessage.Document.URL
				headerMediaType = whatsmeow.MediaDocument
			}

			var err error
			headerMediaInfo, err = processMediaInput(mediaURL)
			if err != nil {
				s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error processing media: %v", err))
				return
			}

			uploaded, err := client.Upload(context.Background(), headerMediaInfo.Data, headerMediaType)
			if err != nil {
				CaptureError(err, r.Context())
				s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("error uploading media: %v", err))
				return
			}

			headerMediaMime = headerMediaInfo.MimeType

			convertMediaType := func(mt whatsmeow.MediaType) MediaType {
				switch mt {
				case whatsmeow.MediaImage:
					return MediaImage
				case whatsmeow.MediaVideo:
					return MediaVideo
				case whatsmeow.MediaDocument:
					return MediaDocument
				default:
					return MediaImage
				}
			}

			headerMedia = &HeaderMedia{
				Type:          convertMediaType(headerMediaType),
				URL:           uploaded.URL,
				MimeType:      headerMediaMime,
				FileSHA256:    string(uploaded.FileSHA256),
				FileEncSHA256: string(uploaded.FileEncSHA256),
				FileLength:    uploaded.FileLength,
				DirectPath:    uploaded.DirectPath,
				MediaKey:      string(uploaded.MediaKey),
				Caption:       buttonsMessage.Caption,
			}

			if headerMediaType == whatsmeow.MediaDocument && buttonsMessage.Document != nil {
				if buttonsMessage.Document.Filename != "" {
					headerMedia.FileName = buttonsMessage.Document.Filename
				} else {
					urlParts := strings.Split(buttonsMessage.Document.URL, "/")
					if len(urlParts) > 0 {
						filename := urlParts[len(urlParts)-1]
						if idx := strings.Index(filename, "?"); idx != -1 {
							filename = filename[:idx]
						}
						if filename != "" {
							headerMedia.FileName = filename
						}
					}
				}
			}

			switch headerMediaType {
			case whatsmeow.MediaImage:
				if thumb, width, height, err := GenerateJPEGThumbnailFromImage(headerMediaInfo.Data, 72, 72); err == nil {
					headerMedia.JPEGThumbnail = thumb
					if headerMediaInfo.Width > 0 {
						headerMedia.Width = headerMediaInfo.Width
					} else {
						headerMedia.Width = width
					}
					if headerMediaInfo.Height > 0 {
						headerMedia.Height = headerMediaInfo.Height
					} else {
						headerMedia.Height = height
					}
				} else {
					log.Warn().Err(err).Msg("failed to generate header image thumbnail")
				}
			case whatsmeow.MediaVideo:
				if thumb, err := GenerateJPEGThumbnailFromVideo(headerMediaInfo.Data); err == nil {
					headerMedia.JPEGThumbnail = thumb
				} else {
					log.Warn().Err(err).Msg("failed to generate header video thumbnail")
				}
			case whatsmeow.MediaDocument:
				if strings.Contains(strings.ToLower(headerMediaMime), "pdf") {
					if pageCount, thumb, err := ProcessPDFDocument(headerMediaInfo.Data); err == nil && len(thumb) > 0 {
						headerMedia.JPEGThumbnail = thumb
						headerMedia.PageCount = pageCount
						if img, _, decodeErr := image.Decode(bytes.NewReader(thumb)); decodeErr == nil {
							bounds := img.Bounds()
							headerMedia.ThumbnailWidth = uint32(bounds.Dx())
							headerMedia.ThumbnailHeight = uint32(bounds.Dy())
						}
					} else {
						if err != nil {
							log.Warn().Err(err).Msg("Failed to generate header PDF thumbnail, using fallback")
						}
						headerMedia.JPEGThumbnail = generateDefaultDocumentThumbnail()
					}
				}
			}
		}

		var body string
		if headerMedia != nil && buttonsMessage.Caption != "" {
			body = buttonsMessage.Caption
		} else if buttonsMessage.Text != "" {
			body = buttonsMessage.Text
		} else {
			s.Respond(w, r, http.StatusBadRequest, errors.New("no body text provided"))
			return
		}

		msgParams := ButtonMessageParams{
			Title:       buttonsMessage.Title,
			Body:        body,
			Footer:      buttonsMessage.Footer,
			Buttons:     waButtons,
			HeaderMedia: headerMedia,
			ContextInfo: &buttonsMessage.ContextInfo,
		}

		messageToSend, err := messageFactory.NewMessageButtons(msgParams)
		if err != nil {
			log.Error().Err(err).Msg("DEBUG: Failed to create button message")
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		if headerMedia != nil && headerMediaInfo != nil {
			interactive := messageToSend.GetInteractiveMessage()
			if interactive != nil {
				header := interactive.GetHeader()
				switch headerMediaType {
				case whatsmeow.MediaImage:
					if imgMsg := header.GetImageMessage(); imgMsg != nil {
						if headerMedia.Width > 0 {
							imgMsg.Width = proto.Uint32(uint32(headerMedia.Width))
						}
						if headerMedia.Height > 0 {
							imgMsg.Height = proto.Uint32(uint32(headerMedia.Height))
						}
					}
				case whatsmeow.MediaVideo:
					if vidMsg := header.GetVideoMessage(); vidMsg != nil && len(headerMedia.JPEGThumbnail) > 0 {
						vidMsg.JPEGThumbnail = headerMedia.JPEGThumbnail
					}
				case whatsmeow.MediaDocument:
					if docMsg := header.GetDocumentMessage(); docMsg != nil {
						temp := &waE2E.Message{DocumentMessage: docMsg}
						ProcessDocument(temp, headerMediaInfo.Data, headerMediaMime)
					}
				}
			}
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &buttonsMessage.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(messageToSend, contextMentions)
		}

		msgid := ""
		licenseKey := os.Getenv("LICENSE_KEY")
		licenseHash := ""
		if licenseKey != "" {
			parts := strings.Split(licenseKey, "-")
			if len(parts) > 0 {
				licenseHash = parts[len(parts)-1]
			}
		}

		if licenseHash != "" {
			msgid = time.Now().Format("20060102150405") + licenseHash
		} else {
			if buttonsMessage.Id == "" {
				msgid = client.GenerateMessageID()
			} else {
				msgid = buttonsMessage.Id
			}
		}

		baseConfig := &BaseMessageConfig{
			Phone:       buttonsMessage.Phone,
			Id:          buttonsMessage.Id,
			Presence:    buttonsMessage.Presence,
			Duration:    buttonsMessage.Duration,
			NumberCheck: buttonsMessage.NumberCheck,
			ContextInfo: buttonsMessage.ContextInfo,
		}

		err = processAllMessageEnhancements(client, recipient, messageToSend, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process button message enhancements")
		}

		sendExtra := whatsmeow.SendRequestExtra{ID: msgid}

		resp, err = s.sendMessageWithEchoByID(context.Background(), txtid, recipient, messageToSend, sendExtra, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
	}
}

// SendFlowMessage sends a native flow interactive message to a recipient (individual or group)
//
//	@Summary		Send flow message
//	@Description	Send a native flow interactive message with custom parameters, supporting flow versioning and media headers.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string	true	"User authentication token"
//	@Router			/chat/send/flow [post]
func (s *server) SendFlowMessage() http.HandlerFunc {
	type flowButtonInput struct {
		Name                string                 `json:"name"`
		ButtonParams        map[string]interface{} `json:"button_params,omitempty"`
		ButtonParamsJSON    string                 `json:"button_params_json,omitempty"`
		NameAlt             string                 `json:"Name,omitempty"`
		ButtonParamsAlt     map[string]interface{} `json:"ButtonParams,omitempty"`
		ButtonParamsJSONAlt string                 `json:"ButtonParamsJSON,omitempty"`
		Params              map[string]interface{} `json:"params,omitempty"`
		ParamsAlt           map[string]interface{} `json:"Params,omitempty"`
		ParamsJSON          string                 `json:"params_json,omitempty"`
		ParamsJSONAlt       string                 `json:"ParamsJSON,omitempty"`
	}

	type flowHeaderMediaInput struct {
		Type        string `json:"type"`
		URL         string `json:"url"`
		Caption     string `json:"caption,omitempty"`
		Filename    string `json:"filename,omitempty"`
		MimeType    string `json:"mimetype,omitempty"`
		TypeAlt     string `json:"Type,omitempty"`
		URLAlt      string `json:"URL,omitempty"`
		CaptionAlt  string `json:"Caption,omitempty"`
		FilenameAlt string `json:"Filename,omitempty"`
		MimeTypeAlt string `json:"MimeType,omitempty"`
	}

	type flowHeaderInput struct {
		Title       string                `json:"title,omitempty"`
		Subtitle    string                `json:"subtitle,omitempty"`
		Media       *flowHeaderMediaInput `json:"media,omitempty"`
		TitleAlt    string                `json:"Title,omitempty"`
		SubtitleAlt string                `json:"Subtitle,omitempty"`
		MediaAlt    *flowHeaderMediaInput `json:"Media,omitempty"`
	}

	type flowMessagePayload struct {
		Phone             string                 `json:"phone"`
		Body              string                 `json:"body,omitempty"`
		Text              string                 `json:"text,omitempty"`
		Message           string                 `json:"message,omitempty"`
		Caption           string                 `json:"caption,omitempty"`
		Footer            string                 `json:"footer,omitempty"`
		Id                string                 `json:"id,omitempty"`
		Presence          *int                   `json:"presence,omitempty"`
		Duration          *uint32                `json:"duration,omitempty"`
		NumberCheck       *bool                  `json:"number_check,omitempty"`
		ContextInfo       waE2E.ContextInfo      `json:"context_info,omitempty"`
		MentionInfo       *MentionInfo           `json:"mention_info,omitempty"`
		ForwardInfo       *ForwardInfo           `json:"forward_info,omitempty"`
		MessageVersion    *int32                 `json:"message_version,omitempty"`
		MessageParams     map[string]interface{} `json:"message_params,omitempty"`
		MessageParamsJSON string                 `json:"message_params_json,omitempty"`
		Header            *flowHeaderInput       `json:"header,omitempty"`
		Buttons           []flowButtonInput      `json:"buttons,omitempty"`

		PhoneAlt             string                 `json:"Phone,omitempty"`
		BodyAlt              string                 `json:"Body,omitempty"`
		TextAlt              string                 `json:"Text,omitempty"`
		MessageAlt           string                 `json:"Message,omitempty"`
		CaptionAlt           string                 `json:"Caption,omitempty"`
		FooterAlt            string                 `json:"Footer,omitempty"`
		IdAlt                string                 `json:"Id,omitempty"`
		PresenceAlt          *int                   `json:"Presence,omitempty"`
		DurationAlt          *uint32                `json:"Duration,omitempty"`
		NumberCheckAlt       *bool                  `json:"NumberCheck,omitempty"`
		ContextInfoAlt       waE2E.ContextInfo      `json:"ContextInfo,omitempty"`
		MessageVersionAlt    *int32                 `json:"MessageVersion,omitempty"`
		MessageParamsAlt     map[string]interface{} `json:"MessageParams,omitempty"`
		MessageParamsJSONAlt string                 `json:"MessageParamsJSON,omitempty"`
		HeaderAlt            *flowHeaderInput       `json:"Header,omitempty"`
		ButtonsAlt           []flowButtonInput      `json:"Buttons,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		var resp whatsmeow.SendResponse

		client := clientManager.GetWhatsmeowClient(txtid)
		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var payload flowMessagePayload
		if err := decoder.Decode(&payload); err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if payload.Phone == "" && payload.PhoneAlt != "" {
			payload.Phone = payload.PhoneAlt
		}
		payload.Phone = strings.TrimSpace(payload.Phone)

		if payload.Body == "" && payload.BodyAlt != "" {
			payload.Body = payload.BodyAlt
		}
		if payload.Text == "" && payload.TextAlt != "" {
			payload.Text = payload.TextAlt
		}
		if payload.Message == "" && payload.MessageAlt != "" {
			payload.Message = payload.MessageAlt
		}
		if payload.Caption == "" && payload.CaptionAlt != "" {
			payload.Caption = payload.CaptionAlt
		}
		if payload.Footer == "" && payload.FooterAlt != "" {
			payload.Footer = payload.FooterAlt
		}
		if payload.Id == "" && payload.IdAlt != "" {
			payload.Id = payload.IdAlt
		}
		payload.Id = strings.TrimSpace(payload.Id)
		payload.Footer = strings.TrimSpace(payload.Footer)

		if payload.Presence == nil && payload.PresenceAlt != nil {
			payload.Presence = payload.PresenceAlt
		}
		if payload.Duration == nil && payload.DurationAlt != nil {
			payload.Duration = payload.DurationAlt
		}
		if payload.NumberCheck == nil && payload.NumberCheckAlt != nil {
			payload.NumberCheck = payload.NumberCheckAlt
		}
		if payload.ContextInfo.StanzaID == nil && payload.ContextInfoAlt.StanzaID != nil {
			payload.ContextInfo = payload.ContextInfoAlt
		}
		if payload.MessageVersion == nil && payload.MessageVersionAlt != nil {
			payload.MessageVersion = payload.MessageVersionAlt
		}
		if payload.MessageParams == nil && payload.MessageParamsAlt != nil {
			payload.MessageParams = payload.MessageParamsAlt
		}
		if payload.MessageParamsJSON == "" && payload.MessageParamsJSONAlt != "" {
			payload.MessageParamsJSON = payload.MessageParamsJSONAlt
		}
		if payload.Header == nil && payload.HeaderAlt != nil {
			payload.Header = payload.HeaderAlt
		}
		if payload.Buttons == nil && payload.ButtonsAlt != nil {
			payload.Buttons = payload.ButtonsAlt
		}

		bodyText := strings.TrimSpace(payload.Body)
		if bodyText == "" {
			bodyText = strings.TrimSpace(payload.Text)
		}
		if bodyText == "" {
			bodyText = strings.TrimSpace(payload.Message)
		}
		if bodyText == "" {
			bodyText = strings.TrimSpace(payload.Caption)
		}
		if bodyText == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing body text in Payload"))
			return
		}

		if payload.Header != nil {
			if payload.Header.Title == "" && payload.Header.TitleAlt != "" {
				payload.Header.Title = payload.Header.TitleAlt
			}
			if payload.Header.Subtitle == "" && payload.Header.SubtitleAlt != "" {
				payload.Header.Subtitle = payload.Header.SubtitleAlt
			}
			if payload.Header.Media == nil && payload.Header.MediaAlt != nil {
				payload.Header.Media = payload.Header.MediaAlt
			}
			if payload.Header.Media != nil {
				if payload.Header.Media.Type == "" && payload.Header.Media.TypeAlt != "" {
					payload.Header.Media.Type = payload.Header.Media.TypeAlt
				}
				if payload.Header.Media.URL == "" && payload.Header.Media.URLAlt != "" {
					payload.Header.Media.URL = payload.Header.Media.URLAlt
				}
				if payload.Header.Media.Caption == "" && payload.Header.Media.CaptionAlt != "" {
					payload.Header.Media.Caption = payload.Header.Media.CaptionAlt
				}
				if payload.Header.Media.Filename == "" && payload.Header.Media.FilenameAlt != "" {
					payload.Header.Media.Filename = payload.Header.Media.FilenameAlt
				}
				if payload.Header.Media.MimeType == "" && payload.Header.Media.MimeTypeAlt != "" {
					payload.Header.Media.MimeType = payload.Header.Media.MimeTypeAlt
				}
				payload.Header.Media.Type = strings.ToLower(strings.TrimSpace(payload.Header.Media.Type))
				payload.Header.Media.URL = strings.TrimSpace(payload.Header.Media.URL)
				payload.Header.Media.Caption = strings.TrimSpace(payload.Header.Media.Caption)
				payload.Header.Media.Filename = strings.TrimSpace(payload.Header.Media.Filename)
				payload.Header.Media.MimeType = strings.TrimSpace(payload.Header.Media.MimeType)
			}
		}

		for i := range payload.Buttons {
			btn := &payload.Buttons[i]
			if btn.Name == "" && btn.NameAlt != "" {
				btn.Name = btn.NameAlt
			}
			if btn.ButtonParams == nil && btn.ButtonParamsAlt != nil {
				btn.ButtonParams = btn.ButtonParamsAlt
			}
			if btn.ButtonParamsJSON == "" && btn.ButtonParamsJSONAlt != "" {
				btn.ButtonParamsJSON = btn.ButtonParamsJSONAlt
			}
			if btn.ButtonParams == nil && btn.Params != nil {
				btn.ButtonParams = btn.Params
			}
			if btn.ButtonParams == nil && btn.ParamsAlt != nil {
				btn.ButtonParams = btn.ParamsAlt
			}
			if btn.ButtonParamsJSON == "" && btn.ParamsJSON != "" {
				btn.ButtonParamsJSON = btn.ParamsJSON
			}
			if btn.ButtonParamsJSON == "" && btn.ParamsJSONAlt != "" {
				btn.ButtonParamsJSON = btn.ParamsJSONAlt
			}
			btn.Name = strings.TrimSpace(btn.Name)
			btn.ButtonParamsJSON = strings.TrimSpace(btn.ButtonParamsJSON)
		}

		if payload.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if len(payload.Buttons) == 0 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("at least one button is required"))
			return
		}

		recipient, err := validateAndGetJID(txtid, payload.Phone, payload.NumberCheck, payload.ContextInfo.StanzaID, payload.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		var nativeFlowButtons []*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton
		for _, btn := range payload.Buttons {
			if btn.Name == "" {
				s.Respond(w, r, http.StatusBadRequest, errors.New("button name is required"))
				return
			}

			paramsJSON := btn.ButtonParamsJSON
			if paramsJSON == "" && btn.ButtonParams != nil {
				paramsBytes, err := json.Marshal(btn.ButtonParams)
				if err != nil {
					s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error marshalling button params: %v", err))
					return
				}
				paramsJSON = string(paramsBytes)
			}
			paramsJSON = strings.TrimSpace(paramsJSON)
			if paramsJSON == "" {
				s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("button params required for '%s'", btn.Name))
				return
			}
			if !json.Valid([]byte(paramsJSON)) {
				s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("invalid JSON in button params for button '%s'", btn.Name))
				return
			}

			nativeFlowButtons = append(nativeFlowButtons, &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
				Name:             proto.String(btn.Name),
				ButtonParamsJSON: proto.String(paramsJSON),
			})
		}

		messageVersion := int32(3)
		if payload.MessageVersion != nil && *payload.MessageVersion > 0 {
			messageVersion = *payload.MessageVersion
		}

		messageParamsJSON := strings.TrimSpace(payload.MessageParamsJSON)
		if messageParamsJSON == "" && payload.MessageParams != nil {
			paramsBytes, err := json.Marshal(payload.MessageParams)
			if err != nil {
				s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error marshalling message params: %v", err))
				return
			}
			messageParamsJSON = string(paramsBytes)
		}
		messageParamsJSON = strings.TrimSpace(messageParamsJSON)
		if messageParamsJSON != "" && !json.Valid([]byte(messageParamsJSON)) {
			s.Respond(w, r, http.StatusBadRequest, errors.New("invalid JSON in message_params"))
			return
		}

		nativeFlowMessage := &waE2E.InteractiveMessage_NativeFlowMessage{
			Buttons:        nativeFlowButtons,
			MessageVersion: proto.Int32(messageVersion),
		}
		if messageParamsJSON != "" {
			nativeFlowMessage.MessageParamsJSON = proto.String(messageParamsJSON)
		}

		interactiveMsg := &waE2E.InteractiveMessage{
			Body: &waE2E.InteractiveMessage_Body{
				Text: proto.String(bodyText),
			},
			InteractiveMessage: &waE2E.InteractiveMessage_NativeFlowMessage_{
				NativeFlowMessage: nativeFlowMessage,
			},
		}

		if payload.Footer != "" {
			interactiveMsg.Footer = &waE2E.InteractiveMessage_Footer{
				Text: proto.String(payload.Footer),
			}
		}

		headerAttached := false
		if payload.Header != nil {
			header := &waE2E.InteractiveMessage_Header{}
			if payload.Header.Title != "" {
				header.Title = proto.String(payload.Header.Title)
				headerAttached = true
			}
			if payload.Header.Subtitle != "" {
				header.Subtitle = proto.String(payload.Header.Subtitle)
				headerAttached = true
			}

			if payload.Header.Media != nil && payload.Header.Media.URL != "" {
				mediaType := payload.Header.Media.Type
				if mediaType == "" {
					mediaType = "image"
				}
				mediaType = strings.ToLower(mediaType)

				mediaInfo, err := processMediaInput(payload.Header.Media.URL)
				if err != nil {
					s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error processing header media: %v", err))
					return
				}

				var uploadType whatsmeow.MediaType
				switch mediaType {
				case "image":
					uploadType = whatsmeow.MediaImage
				case "video":
					uploadType = whatsmeow.MediaVideo
				case "document":
					uploadType = whatsmeow.MediaDocument
				default:
					s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("unsupported header media type: %s", mediaType))
					return
				}

				uploaded, err := client.Upload(context.Background(), mediaInfo.Data, uploadType)
				if err != nil {
					CaptureError(err, r.Context())
					s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("error uploading header media: %v", err))
					return
				}

				header.HasMediaAttachment = proto.Bool(true)
				mimeType := mediaInfo.MimeType
				if payload.Header.Media.MimeType != "" {
					mimeType = payload.Header.Media.MimeType
				}

				switch uploadType {
				case whatsmeow.MediaImage:
					img := &waE2E.ImageMessage{
						URL:           proto.String(uploaded.URL),
						Mimetype:      proto.String(mimeType),
						FileSHA256:    uploaded.FileSHA256,
						FileEncSHA256: uploaded.FileEncSHA256,
						FileLength:    proto.Uint64(uploaded.FileLength),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
					}
					if payload.Header.Media.Caption != "" {
						img.Caption = proto.String(payload.Header.Media.Caption)
					}
					header.Media = &waE2E.InteractiveMessage_Header_ImageMessage{
						ImageMessage: img,
					}
				case whatsmeow.MediaVideo:
					vid := &waE2E.VideoMessage{
						URL:           proto.String(uploaded.URL),
						Mimetype:      proto.String(mimeType),
						FileSHA256:    uploaded.FileSHA256,
						FileEncSHA256: uploaded.FileEncSHA256,
						FileLength:    proto.Uint64(uploaded.FileLength),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
					}
					if payload.Header.Media.Caption != "" {
						vid.Caption = proto.String(payload.Header.Media.Caption)
					}
					header.Media = &waE2E.InteractiveMessage_Header_VideoMessage{
						VideoMessage: vid,
					}
				case whatsmeow.MediaDocument:
					doc := &waE2E.DocumentMessage{
						URL:           proto.String(uploaded.URL),
						Mimetype:      proto.String(mimeType),
						FileSHA256:    uploaded.FileSHA256,
						FileEncSHA256: uploaded.FileEncSHA256,
						FileLength:    proto.Uint64(uploaded.FileLength),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
					}
					if payload.Header.Media.Filename != "" {
						doc.FileName = proto.String(payload.Header.Media.Filename)
					}
					if payload.Header.Media.Caption != "" {
						doc.Caption = proto.String(payload.Header.Media.Caption)
					}
					header.Media = &waE2E.InteractiveMessage_Header_DocumentMessage{
						DocumentMessage: doc,
					}
				}
				headerAttached = true
			}

			if headerAttached {
				interactiveMsg.Header = header
			}
		}

		if !proto.Equal(&payload.ContextInfo, &waE2E.ContextInfo{}) {
			interactiveMsg.ContextInfo = &payload.ContextInfo
		}

		messageToSend := &waE2E.Message{
			InteractiveMessage: interactiveMsg,
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &payload.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(messageToSend, contextMentions)
		}

		if payload.MentionInfo != nil {
			mentionedJIDs, err := s.processUniversalMentions(txtid, recipient, payload.MentionInfo)
			if err != nil {
				log.Warn().Err(err).Msg("Failed to process mentions in flow message")
			} else if len(mentionedJIDs) > 0 {
				addMentionsToMessage(messageToSend, mentionedJIDs)
			}
		}

		if isForwarded := s.processUniversalForwardWithJSON(payload.ForwardInfo, &payload.ContextInfo, bodyBytes); isForwarded {
			addForwardToMessage(messageToSend, isForwarded)
		}

		msgid := ""
		licenseKey := os.Getenv("LICENSE_KEY")
		licenseHash := ""
		if licenseKey != "" {
			parts := strings.Split(licenseKey, "-")
			if len(parts) > 0 {
				licenseHash = parts[len(parts)-1]
			}
		}

		if licenseHash != "" {
			msgid = time.Now().Format("20060102150405") + licenseHash
		} else if payload.Id != "" {
			msgid = payload.Id
		} else {
			msgid = client.GenerateMessageID()
		}

		baseConfig := &BaseMessageConfig{
			Phone:       payload.Phone,
			Id:          payload.Id,
			Presence:    payload.Presence,
			Duration:    payload.Duration,
			NumberCheck: payload.NumberCheck,
			ContextInfo: payload.ContextInfo,
		}

		if err := processAllMessageEnhancements(client, recipient, messageToSend, baseConfig, false); err != nil {
			log.Warn().Err(err).Msg("Failed to process flow message enhancements")
		}

		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, messageToSend, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
			return
		}

		s.Respond(w, r, http.StatusOK, string(responseJson))
	}
}

// SendListMessage sends a message with an interactive list to a recipient (individual or group)
//
//	@Summary		Send list message
//	@Description	Send a message with an interactive list to a phone number or group. This endpoint creates rich, structured lists perfect for product catalogs, service menus, restaurant menus, and interactive selections.
//
// **LIST STRUCTURE:**
// - **Title**: Main heading of the list (required)
// - **Text**: Descriptive text explaining the list content (required)
// - **Footer**: Additional information or instructions (optional)
// - **ButtonText**: Text for the main action button (required)
// - **Sections**: Array of list sections (1-10 sections max)
//
// **SECTION STRUCTURE:**
// - **Title**: Section heading (required)
// - **Rows**: Array of list items (1-10 rows per section)
//
// **ROW STRUCTURE:**
// - **RowId**: Unique identifier for the row (required)
// - **Title**: Row title/name (required)
// - **Description**: Detailed description of the item (required)
//
// **USE CASES:**
// -  **Product Catalogs**: Show products with prices and descriptions
// -  **Restaurant Menus**: Display food items with prices
// -  **Service Lists**: List available services with details
// -  **Survey Options**: Present multiple choice options
// -  **Feature Lists**: Show product features and benefits
//
// **LIMITATIONS:**
//
//   - Maximum 10 sections per list
//
//   - Maximum 10 rows per section
//
//   - Total maximum 100 rows across all sections
//
//   - Text fields have character limits (Title: 60, Description: 72)
//
//     @Tags			Chat
//     @Accept			json
//     @Produce		json
//     @Param			token	header		string					true	"User authentication token"
//     @Router			/chat/send/list [post]
func (s *server) SendListMessage() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)
		var resp whatsmeow.SendResponse

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		type Row struct {
			Title          string `json:"title"`
			Description    string `json:"description"`
			RowID          string `json:"rowId"`
			TitleAlt       string `json:"Title,omitempty"`
			DescriptionAlt string `json:"Description,omitempty"`
			RowIDAlt       string `json:"RowId,omitempty"`
			RowIDAltUpper  string `json:"RowID,omitempty"`
		}

		type Section struct {
			Title    string `json:"title"`
			Rows     []Row  `json:"rows"`
			TitleAlt string `json:"Title,omitempty"`
			RowsAlt  []Row  `json:"Rows,omitempty"`
		}

		type ListMessage struct {
			Phone       string            `json:"phone,omitempty"`
			Text        string            `json:"text,omitempty"`
			Footer      string            `json:"footer,omitempty"`
			Title       string            `json:"title,omitempty"`
			ButtonText  string            `json:"buttonText,omitempty"`
			Sections    []Section         `json:"sections,omitempty"`
			Id          string            `json:"id,omitempty"`
			Presence    *int              `json:"presence,omitempty"`
			Duration    *uint32           `json:"duration,omitempty"`
			NumberCheck *bool             `json:"number_check,omitempty"`
			ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`

			PhoneAlt       string            `json:"Phone,omitempty"`
			TextAlt        string            `json:"Text,omitempty"`
			FooterAlt      string            `json:"Footer,omitempty"`
			TitleAlt       string            `json:"Title,omitempty"`
			ButtonTextAlt  string            `json:"ButtonText,omitempty"`
			SectionsAlt    []Section         `json:"Sections,omitempty"`
			IdAlt          string            `json:"Id,omitempty"`
			PresenceAlt    *int              `json:"Presence,omitempty"`
			DurationAlt    *uint32           `json:"Duration,omitempty"`
			NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
			ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
		}

		var listMsg ListMessage
		decoder := json.NewDecoder(r.Body)
		err = decoder.Decode(&listMsg)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		if listMsg.Phone == "" && listMsg.PhoneAlt != "" {
			listMsg.Phone = listMsg.PhoneAlt
		}
		if listMsg.Text == "" && listMsg.TextAlt != "" {
			listMsg.Text = listMsg.TextAlt
		}
		if listMsg.Footer == "" && listMsg.FooterAlt != "" {
			listMsg.Footer = listMsg.FooterAlt
		}
		if listMsg.Title == "" && listMsg.TitleAlt != "" {
			listMsg.Title = listMsg.TitleAlt
		}
		if listMsg.ButtonText == "" && listMsg.ButtonTextAlt != "" {
			listMsg.ButtonText = listMsg.ButtonTextAlt
		}
		if listMsg.Sections == nil && listMsg.SectionsAlt != nil {
			listMsg.Sections = listMsg.SectionsAlt
		}
		if listMsg.Id == "" && listMsg.IdAlt != "" {
			listMsg.Id = listMsg.IdAlt
		}
		if listMsg.Presence == nil && listMsg.PresenceAlt != nil {
			listMsg.Presence = listMsg.PresenceAlt
		}
		if listMsg.Duration == nil && listMsg.DurationAlt != nil {
			listMsg.Duration = listMsg.DurationAlt
		}
		if listMsg.NumberCheck == nil && listMsg.NumberCheckAlt != nil {
			listMsg.NumberCheck = listMsg.NumberCheckAlt
		}
		if listMsg.ContextInfo.StanzaID == nil && listMsg.ContextInfoAlt.StanzaID != nil {
			listMsg.ContextInfo = listMsg.ContextInfoAlt
		}

		normalizeRow := func(row *Row) {
			if row == nil {
				return
			}
			if row.Title == "" && row.TitleAlt != "" {
				row.Title = row.TitleAlt
			}
			if row.Description == "" && row.DescriptionAlt != "" {
				row.Description = row.DescriptionAlt
			}
			if row.RowID == "" && row.RowIDAlt != "" {
				row.RowID = row.RowIDAlt
			}
			if row.RowID == "" && row.RowIDAltUpper != "" {
				row.RowID = row.RowIDAltUpper
			}
		}

		normalizeSection := func(section *Section) {
			if section == nil {
				return
			}
			if section.Title == "" && section.TitleAlt != "" {
				section.Title = section.TitleAlt
			}
			if len(section.Rows) == 0 && len(section.RowsAlt) > 0 {
				section.Rows = section.RowsAlt
			}
			for idx := range section.Rows {
				normalizeRow(&section.Rows[idx])
			}
		}

		for idx := range listMsg.Sections {
			normalizeSection(&listMsg.Sections[idx])
		}

		if listMsg.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if listMsg.Text == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Text in Payload"))
			return
		}

		if listMsg.ButtonText == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing ButtonText in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, listMsg.Phone, listMsg.NumberCheck, listMsg.ContextInfo.StanzaID, listMsg.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		var sections []*waE2E.ListMessage_Section
		for _, sec := range listMsg.Sections {
			var rows []*waE2E.ListMessage_Row
			for _, row := range sec.Rows {
				rowFactory := ListMessageRowFactory{
					ID:          row.RowID,
					Title:       row.Title,
					Description: row.Description,
				}
				listRow, err := rowFactory.New(row.Title, row.Description, row.RowID)
				if err != nil {
					log.Error().Err(err).Str("row_id", row.RowID).Msg("DEBUG: Failed to create row")
					s.Respond(w, r, http.StatusBadRequest, err)
					return
				}
				rows = append(rows, listRow)
			}

			sectionFactory := ListMessageSectionFactory{
				Title: sec.Title,
				Rows:  []ListMessageRowFactory{},
			}
			listSection, err := sectionFactory.New(sec.Title, rows)
			if err != nil {
				log.Error().Err(err).Str("section_title", sec.Title).Msg("DEBUG: Failed to create section")
				s.Respond(w, r, http.StatusBadRequest, err)
				return
			}

			sections = append(sections, listSection)
		}

		var ctxInfo *waE2E.ContextInfo
		if listMsg.ContextInfo.StanzaID != nil || listMsg.ContextInfo.Participant != nil {
			ctxInfo = &listMsg.ContextInfo
		}

		listMsgFactory := ListMessageFactory{
			Title:       listMsg.Title,
			Description: listMsg.Text,
			ButtonText:  listMsg.ButtonText,
			Footer:      listMsg.Footer,
			Sections:    []ListMessageSectionFactory{},
		}

		message, err := listMsgFactory.New(
			listMsg.Title,
			listMsg.Text,
			listMsg.ButtonText,
			listMsg.Footer,
			sections,
			ctxInfo,
		)
		if err != nil {
			log.Error().Err(err).Msg("DEBUG: Failed to create list message")
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &listMsg.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(message, contextMentions)
		}

		msgid := ""
		licenseKey := os.Getenv("LICENSE_KEY")
		licenseHash := ""
		if licenseKey != "" {
			parts := strings.Split(licenseKey, "-")
			if len(parts) > 0 {
				licenseHash = parts[len(parts)-1]
			}
		}

		if licenseHash != "" {
			msgid = time.Now().Format("20060102150405") + licenseHash
		} else {
			if listMsg.Id == "" {
				msgid = client.GenerateMessageID()
			} else {
				msgid = listMsg.Id
			}
		}

		baseConfig := &BaseMessageConfig{
			Phone:       listMsg.Phone,
			Id:          listMsg.Id,
			Presence:    listMsg.Presence,
			Duration:    listMsg.Duration,
			NumberCheck: listMsg.NumberCheck,
			ContextInfo: listMsg.ContextInfo,
		}

		err = processAllMessageEnhancements(client, recipient, message, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process list message enhancements")
		}

		resp, err = s.sendMessageWithEchoByID(context.Background(), txtid, recipient, message, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("List message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
	}
}

// SendCarouselMessage sends a carousel message to a recipient
//
//	@Summary		Send carousel message
//	@Description	Send a carousel message with multiple cards to a phone number or group. Each card can contain images, videos, documents, text, and buttons.
//	@Tags			Chat
//	@Accept			json
//	@Produce		json
//	@Param			token	header		string						true	"User authentication token"
//	@Router			/chat/send/carousel [post]
func (s *server) SendCarouselMessage() http.HandlerFunc {
	type buttonStruct struct {
		Id       string `json:"id"`
		Label    string `json:"label"`
		Url      string `json:"url"`
		Type     string `json:"type"`
		IdAlt    string `json:"Id,omitempty"`
		LabelAlt string `json:"Label,omitempty"`
		UrlAlt   string `json:"Url,omitempty"`
		URLAlt   string `json:"URL,omitempty"`
		TypeAlt  string `json:"Type,omitempty"`
	}

	type cardStruct struct {
		Text           string         `json:"text"`
		MediaURL       string         `json:"media_url,omitempty"`
		MediaType      string         `json:"media_type,omitempty"`
		Filename       string         `json:"filename,omitempty"`
		Caption        string         `json:"caption,omitempty"`
		Buttons        []buttonStruct `json:"buttons"`
		TextAlt        string         `json:"Text,omitempty"`
		MediaURLAlt    string         `json:"MediaUrl,omitempty"`
		MediaURLAltAll string         `json:"MediaURL,omitempty"`
		MediaTypeAlt   string         `json:"MediaType,omitempty"`
		FilenameAlt    string         `json:"Filename,omitempty"`
		CaptionAlt     string         `json:"Caption,omitempty"`
		ButtonsAlt     []buttonStruct `json:"Buttons,omitempty"`
	}

	type CarouselStruct struct {
		Phone       string            `json:"phone"`
		Message     string            `json:"message"`
		Carousel    []cardStruct      `json:"carousel"`
		Id          string            `json:"id,omitempty"`
		Presence    *int              `json:"presence,omitempty"`
		Duration    *uint32           `json:"duration,omitempty"`
		NumberCheck *bool             `json:"number_check,omitempty"`
		ContextInfo waE2E.ContextInfo `json:"context_info,omitempty"`

		PhoneAlt       string            `json:"Phone,omitempty"`
		MessageAlt     string            `json:"Message,omitempty"`
		CarouselAlt    []cardStruct      `json:"Carousel,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		DurationAlt    *uint32           `json:"Duration,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {

		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		var resp whatsmeow.SendResponse

		client := clientManager.GetWhatsmeowClient(txtid)
		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("no session"))
			return
		}

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		var t CarouselStruct
		decoder := json.NewDecoder(r.Body)
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not decode Payload"))
			return
		}

		normalizeCarouselButton := func(btn *buttonStruct) {
			if btn == nil {
				return
			}
			if btn.Id == "" && btn.IdAlt != "" {
				btn.Id = btn.IdAlt
			}
			if btn.Label == "" && btn.LabelAlt != "" {
				btn.Label = btn.LabelAlt
			}
			if btn.Url == "" {
				switch {
				case btn.UrlAlt != "":
					btn.Url = btn.UrlAlt
				case btn.URLAlt != "":
					btn.Url = btn.URLAlt
				}
			}
			if btn.Type == "" && btn.TypeAlt != "" {
				btn.Type = btn.TypeAlt
			}
		}

		normalizeCarouselCard := func(card *cardStruct) {
			if card == nil {
				return
			}
			if card.Text == "" && card.TextAlt != "" {
				card.Text = card.TextAlt
			}
			if card.MediaURL == "" {
				switch {
				case card.MediaURLAlt != "":
					card.MediaURL = card.MediaURLAlt
				case card.MediaURLAltAll != "":
					card.MediaURL = card.MediaURLAltAll
				}
			}
			if card.MediaType == "" && card.MediaTypeAlt != "" {
				card.MediaType = card.MediaTypeAlt
			}
			if card.Filename == "" && card.FilenameAlt != "" {
				card.Filename = card.FilenameAlt
			}
			if card.Caption == "" && card.CaptionAlt != "" {
				card.Caption = card.CaptionAlt
			}
			if len(card.Buttons) == 0 && len(card.ButtonsAlt) > 0 {
				card.Buttons = card.ButtonsAlt
			}
			for idx := range card.Buttons {
				normalizeCarouselButton(&card.Buttons[idx])
			}
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Message == "" && t.MessageAlt != "" {
			t.Message = t.MessageAlt
		}
		if len(t.Carousel) == 0 && len(t.CarouselAlt) > 0 {
			t.Carousel = t.CarouselAlt
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.Duration == nil && t.DurationAlt != nil {
			t.Duration = t.DurationAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}

		for idx := range t.Carousel {
			normalizeCarouselCard(&t.Carousel[idx])
		}

		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Phone in Payload"))
			return
		}

		if len(t.Carousel) == 0 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("missing Carousel in Payload"))
			return
		}

		recipient, err := validateAndGetJID(txtid, t.Phone, t.NumberCheck, t.ContextInfo.StanzaID, t.ContextInfo.Participant)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, err)
			return
		}

		// Create dynamic cards from the payload
		var cards []*waE2E.InteractiveMessage

		for _, card := range t.Carousel {
			var buttons []*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton

			// Create buttons
			for _, button := range card.Buttons {
				buttonType := strings.ToLower(button.Type)

				var buttonParamsJSON string
				switch buttonType {
				case "url":
					buttonParamsJSON = `{"display_text":"` + button.Label + `","url":"` + button.Url + `","fix":true,"merchant_url":"` + button.Url + `"}`
					buttons = append(buttons, &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
						Name:             proto.String("cta_url"),
						ButtonParamsJSON: proto.String(buttonParamsJSON),
					})
				case "reply":
					buttonParamsJSON = `{"display_text":"` + button.Label + `","id":"` + button.Id + `","disabled":false,"fix":true}`
					buttons = append(buttons, &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
						Name:             proto.String("quick_reply"),
						ButtonParamsJSON: proto.String(buttonParamsJSON),
					})
				case "copy":
					buttonParamsJSON = `{"display_text":"` + button.Label + `","id":"` + button.Id + `","disabled":false,"copy_code":"` + button.Id + `"}`
					buttons = append(buttons, &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
						Name:             proto.String("cta_copy"),
						ButtonParamsJSON: proto.String(buttonParamsJSON),
					})
				case "call":
					buttonParamsJSON = `{"display_text":"` + button.Label + `","id":"` + button.Id + `","disabled":false,"phone_number":"` + button.Id + `"}`
					buttons = append(buttons, &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
						Name:             proto.String("cta_call"),
						ButtonParamsJSON: proto.String(buttonParamsJSON),
					})
				default:
					continue // Skip invalid button types
				}
			}

			var carouselHeader *waE2E.InteractiveMessage_Header

			// Process media if present
			if card.MediaURL != "" && card.MediaType != "" {
				mediaInfo, err := processMediaInput(card.MediaURL)
				if err != nil {
					s.Respond(w, r, http.StatusBadRequest, fmt.Errorf("error processing media: %v", err))
					return
				}

				var uploadType whatsmeow.MediaType
				switch card.MediaType {
				case "image":
					uploadType = whatsmeow.MediaImage
				case "video":
					uploadType = whatsmeow.MediaVideo
				case "document":
					uploadType = whatsmeow.MediaDocument
				default:
					s.Respond(w, r, http.StatusBadRequest, errors.New("invalid media type"))
					return
				}

				uploaded, err := client.Upload(context.Background(), mediaInfo.Data, uploadType)
				if err != nil {
					CaptureError(err, r.Context())
					s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("failed to upload file: %v", err))
					return
				}

				mimeType := mediaInfo.MimeType
				if mimeType == "" || mimeType == "application/octet-stream" {
					mimeType = http.DetectContentType(mediaInfo.Data)
				}

				var media *waE2E.Message
				switch card.MediaType {
				case "image":
					media = &waE2E.Message{ImageMessage: &waE2E.ImageMessage{
						Caption:       proto.String(card.Caption),
						URL:           proto.String(uploaded.URL),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
						Mimetype:      proto.String(mimeType),
						FileEncSHA256: uploaded.FileEncSHA256,
						FileSHA256:    uploaded.FileSHA256,
						FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
						ViewOnce:      proto.Bool(false),
					}}

					if mediaInfo.Width > 0 {
						media.ImageMessage.Width = proto.Uint32(uint32(mediaInfo.Width))
					}
					if mediaInfo.Height > 0 {
						media.ImageMessage.Height = proto.Uint32(uint32(mediaInfo.Height))
					}

					if thumb, _, _, err := GenerateJPEGThumbnailFromImage(mediaInfo.Data, 72, 72); err == nil {
						media.ImageMessage.JPEGThumbnail = thumb
					} else {
						log.Warn().Err(err).Msg("failed to generate carousel image thumbnail")
					}

					carouselHeader = &waE2E.InteractiveMessage_Header{
						Media: &waE2E.InteractiveMessage_Header_ImageMessage{
							ImageMessage: media.ImageMessage,
						},
						HasMediaAttachment: proto.Bool(true),
					}

				case "video":
					media = &waE2E.Message{VideoMessage: &waE2E.VideoMessage{
						Caption:       proto.String(card.Caption),
						URL:           proto.String(uploaded.URL),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
						Mimetype:      proto.String(mimeType),
						FileEncSHA256: uploaded.FileEncSHA256,
						FileSHA256:    uploaded.FileSHA256,
						FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
						ViewOnce:      proto.Bool(false),
					}}

					if thumb, err := GenerateJPEGThumbnailFromVideo(mediaInfo.Data); err == nil {
						media.VideoMessage.JPEGThumbnail = thumb
					} else {
						log.Warn().Err(err).Msg("failed to generate carousel video thumbnail")
					}

					carouselHeader = &waE2E.InteractiveMessage_Header{
						Media: &waE2E.InteractiveMessage_Header_VideoMessage{
							VideoMessage: media.VideoMessage,
						},
						HasMediaAttachment: proto.Bool(true),
					}

				case "document":
					filename := card.Filename
					if filename == "" {
						filename = "document"
					}
					media = &waE2E.Message{DocumentMessage: &waE2E.DocumentMessage{
						URL:           proto.String(uploaded.URL),
						Caption:       proto.String(card.Caption),
						FileName:      proto.String(filename),
						DirectPath:    proto.String(uploaded.DirectPath),
						MediaKey:      uploaded.MediaKey,
						Mimetype:      proto.String(mimeType),
						FileEncSHA256: uploaded.FileEncSHA256,
						FileSHA256:    uploaded.FileSHA256,
						FileLength:    proto.Uint64(uint64(len(mediaInfo.Data))),
					}}

					ProcessDocument(media, mediaInfo.Data, mimeType)

					carouselHeader = &waE2E.InteractiveMessage_Header{
						Media: &waE2E.InteractiveMessage_Header_DocumentMessage{
							DocumentMessage: media.DocumentMessage,
						},
						HasMediaAttachment: proto.Bool(true),
					}
				}
			}

			// Create the card message with the media
			cardMessage := &waE2E.InteractiveMessage{
				Body: &waE2E.InteractiveMessage_Body{
					Text: proto.String(card.Text),
				},
				Header: carouselHeader,
				InteractiveMessage: &waE2E.InteractiveMessage_NativeFlowMessage_{
					NativeFlowMessage: &waE2E.InteractiveMessage_NativeFlowMessage{
						Buttons: buttons,
					},
				},
			}

			cards = append(cards, cardMessage)
		}

		// Create final carousel message
		msg := &waE2E.Message{
			InteractiveMessage: &waE2E.InteractiveMessage{
				Body: &waE2E.InteractiveMessage_Body{
					Text: proto.String(t.Message),
				},
				InteractiveMessage: &waE2E.InteractiveMessage_CarouselMessage_{
					CarouselMessage: &waE2E.InteractiveMessage_CarouselMessage{
						Cards:          cards,
						MessageVersion: proto.Int32(1),
					},
				},
			},
		}

		// Process mentions
		contextMentions := s.processContextInfoMentionAll(txtid, recipient, &t.ContextInfo, bodyBytes)
		if len(contextMentions) > 0 {
			addMentionsToMessage(msg, contextMentions)
		}

		// Generate message ID
		msgid := ""
		licenseKey := os.Getenv("LICENSE_KEY")
		licenseHash := ""
		if licenseKey != "" {
			parts := strings.Split(licenseKey, "-")
			if len(parts) > 0 {
				licenseHash = parts[len(parts)-1]
			}
		}

		if licenseHash != "" {
			msgid = time.Now().Format("20060102150405") + licenseHash
		} else {
			if t.Id == "" {
				msgid = client.GenerateMessageID()
			} else {
				msgid = t.Id
			}
		}

		// Process message enhancements
		baseConfig := &BaseMessageConfig{
			Phone:       t.Phone,
			Id:          t.Id,
			Presence:    t.Presence,
			Duration:    t.Duration,
			NumberCheck: t.NumberCheck,
			ContextInfo: t.ContextInfo,
		}

		err = processAllMessageEnhancements(client, recipient, msg, baseConfig, false)
		if err != nil {
			log.Warn().Err(err).Msg("Failed to process carousel message enhancements")
		}

		// Send message
		resp, err = s.sendMessageWithEcho(context.Background(), txtid, client, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending carousel message: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Carousel message sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
	}
}

// SendEvent sends an event message to a recipient (individual or group)
//
//	@Summary		Send event message
//	@Description	Send an event message to a phone number or group. This endpoint creates rich event invitations with scheduling, location, and call integration capabilities.
//
// **EVENT STRUCTURE:**
// - **Name**: Event title/name (required)
// - **Description**: Detailed event description (optional)
// - **StartTime**: Unix timestamp for event start (required)
// - **EndTime**: Unix timestamp for event end (optional)
// - **ExtraGuestsAllowed**: Allow additional guests (optional)
// - **IsCanceled**: Mark event as cancelled (optional)
// - **JoinLink**: Meeting link for virtual events (not supported yet)
// - **IsScheduleCall**: Indicate if this is a scheduled call (optional)
// - **CallType**: Type of call - "video" or "voice" (not supported yet, when IsScheduleCall=true)
// - **Participants**: List of participant phone numbers (not supported yet, for groups)
// - **Location**: Event location details (optional)
//
// **LOCATION STRUCTURE:**
// - **Name**: Location name/address (required)
// - **DegreesLongitude**: Longitude coordinate (optional)
// - **DegreesLatitude**: Latitude coordinate (optional)
//
// **USE CASES:**
// -  **Meeting Invitations**: Team meetings, client calls
// -  **Event Planning**: Parties, conferences, workshops
// -  **Call Scheduling**: Video/voice conference calls
// -  **Location Events**: In-person meetings with maps
// -  **Event Cancellations**: Notify about cancelled events
//
// **FEATURES:**
//
//   -  **Virtual Meetings**: Support for video/voice calls
//
//   -  **Location Integration**: GPS coordinates and addresses
//
//   -  **Group Support**: Participant management for groups
//
//   -  **Join Links**: Direct meeting room access
//
//   -  **Scheduling**: Start/end time management
//
//     @Summary		Send event message
//     @Description	Send calendar event invitation with date, time, location, and description to a WhatsApp contact or group. Recipients can add the event to their calendar. Features include replies, forwarding, and ephemeral messages.
//     @Tags			Chat
//     @Accept			json
//     @Produce		json
//     @Param			token	header		string						true	"User authentication token"
//     @Router			/chat/send/event [post]
func (s *server) SendEvent() http.HandlerFunc {
	type eventStruct struct {
		Phone              string            `json:"phone"`
		Name               string            `json:"name"`
		Description        *string           `json:"description,omitempty"`
		StartTime          int64             `json:"start_time"`
		EndTime            *int64            `json:"end_time,omitempty"`
		ExtraGuestsAllowed bool              `json:"extra_guests_allowed,omitempty"`
		IsCanceled         bool              `json:"is_canceled,omitempty"`
		IsScheduleCall     bool              `json:"is_schedule_call,omitempty"`
		Id                 string            `json:"id,omitempty"`
		Presence           *int              `json:"presence,omitempty"`
		NumberCheck        *bool             `json:"number_check,omitempty"`
		ContextInfo        waE2E.ContextInfo `json:"context_info,omitempty"`
		Location           *struct {
			Name             string   `json:"name,omitempty"`
			DegreesLongitude *float64 `json:"degrees_longitude,omitempty"`
			DegreesLatitude  *float64 `json:"degrees_latitude,omitempty"`
		} `json:"location,omitempty"`

		PhoneAlt              string  `json:"Phone,omitempty"`
		NameAlt               string  `json:"Name,omitempty"`
		DescriptionAlt        *string `json:"Description,omitempty"`
		StartTimeAlt          int64   `json:"StartTime,omitempty"`
		EndTimeAlt            *int64  `json:"EndTime,omitempty"`
		ExtraGuestsAllowedAlt bool    `json:"ExtraGuestsAllowed,omitempty"`
		IsCanceledAlt         bool    `json:"IsCanceled,omitempty"`
		// JoinLinkAlt           *string           `json:"JoinLink,omitempty"`
		IsScheduleCallAlt bool `json:"IsScheduleCall,omitempty"`
		LocationAlt       *struct {
			NameAlt             string   `json:"Name,omitempty"`
			DegreesLongitudeAlt *float64 `json:"DegreesLongitude,omitempty"`
			DegreesLatitudeAlt  *float64 `json:"DegreesLatitude,omitempty"`
		} `json:"location,omitempty"`
		IdAlt          string            `json:"Id,omitempty"`
		PresenceAlt    *int              `json:"Presence,omitempty"`
		NumberCheckAlt *bool             `json:"NumberCheck,omitempty"`
		ContextInfoAlt waE2E.ContextInfo `json:"ContextInfo,omitempty"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		txtid := r.Context().Value("userinfo").(Values).Get("Id")
		client := clientManager.GetWhatsmeowClient(txtid)

		if client == nil {
			s.Respond(w, r, http.StatusInternalServerError, errors.New("No session"))
			return
		}

		var resp whatsmeow.SendResponse

		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("could not read request body"))
			return
		}

		// Extract EchoApi flag from request body
		forceEcho := extractEchoApiFlag(bodyBytes)

		r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

		decoder := json.NewDecoder(r.Body)
		var t eventStruct
		err = decoder.Decode(&t)
		if err != nil {
			s.Respond(w, r, http.StatusBadRequest, errors.New("Could not decode Payload"))
			return
		}

		if t.Phone == "" && t.PhoneAlt != "" {
			t.Phone = t.PhoneAlt
		}
		if t.Name == "" && t.NameAlt != "" {
			t.Name = t.NameAlt
		}
		if t.Description == nil && t.DescriptionAlt != nil {
			t.Description = t.DescriptionAlt
		}
		if t.StartTime == 0 && t.StartTimeAlt != 0 {
			t.StartTime = t.StartTimeAlt
		}
		if t.EndTime == nil && t.EndTimeAlt != nil {
			t.EndTime = t.EndTimeAlt
		}
		if !t.ExtraGuestsAllowed && t.ExtraGuestsAllowedAlt {
			t.ExtraGuestsAllowed = t.ExtraGuestsAllowedAlt
		}
		if !t.IsCanceled && t.IsCanceledAlt {
			t.IsCanceled = t.IsCanceledAlt
		}
		// if t.JoinLink == nil && t.JoinLinkAlt != nil {
		// 	t.JoinLink = t.JoinLinkAlt
		// }
		if !t.IsScheduleCall && t.IsScheduleCallAlt {
			t.IsScheduleCall = t.IsScheduleCallAlt
		}
		if t.Location == nil && t.LocationAlt != nil {
			t.Location = &struct {
				Name             string   `json:"name,omitempty"`
				DegreesLongitude *float64 `json:"degrees_longitude,omitempty"`
				DegreesLatitude  *float64 `json:"degrees_latitude,omitempty"`
			}{
				Name:             t.LocationAlt.NameAlt,
				DegreesLongitude: t.LocationAlt.DegreesLongitudeAlt,
				DegreesLatitude:  t.LocationAlt.DegreesLatitudeAlt,
			}
		}
		if t.Id == "" && t.IdAlt != "" {
			t.Id = t.IdAlt
		}
		if t.Presence == nil && t.PresenceAlt != nil {
			t.Presence = t.PresenceAlt
		}
		if t.NumberCheck == nil && t.NumberCheckAlt != nil {
			t.NumberCheck = t.NumberCheckAlt
		}
		if t.ContextInfo.StanzaID == nil && t.ContextInfoAlt.StanzaID != nil {
			t.ContextInfo = t.ContextInfoAlt
		}
		if t.Phone == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("Missing phone in Payload"))
			return
		}

		if t.Name == "" {
			s.Respond(w, r, http.StatusBadRequest, errors.New("Missing name in Payload"))
			return
		}

		if t.StartTime == 0 {
			s.Respond(w, r, http.StatusBadRequest, errors.New("Missing start_time in Payload"))
			return
		}

		recipient, ok := parseJID(t.Phone)
		if !ok {
			s.Respond(w, r, http.StatusBadRequest, errors.New("Could not parse JID"))
			return
		}

		if t.NumberCheck != nil && *t.NumberCheck {
			onwhatsapp, err := client.IsOnWhatsApp(r.Context(), []string{t.Phone})
			if err != nil {
				CaptureError(err, r.Context())
				s.Respond(w, r, http.StatusInternalServerError, fmt.Errorf("Failed to check if %s is on WhatsApp: %v", t.Phone, err))
				return
			}
			if len(onwhatsapp) > 0 && !onwhatsapp[0].IsIn {
				s.Respond(w, r, http.StatusBadRequest, errors.New("Number is not on WhatsApp"))
				return
			}
		}

		msgid := t.Id
		if msgid == "" {
			msgid = whatsmeow.GenerateMessageID()
		}

		msgSecret := make([]byte, 32)
		for i := range msgSecret {
			msgSecret[i] = byte(rand.Intn(256))
		}

		eventMessage := &waE2E.EventMessage{
			Name:               proto.String(t.Name),
			Description:        t.Description,
			StartTime:          proto.Int64(t.StartTime),
			EndTime:            t.EndTime,
			ExtraGuestsAllowed: proto.Bool(t.ExtraGuestsAllowed),
			IsCanceled:         proto.Bool(t.IsCanceled),
			// JoinLink:           t.JoinLink, // not supported yet
			IsScheduleCall: proto.Bool(t.IsScheduleCall),
		}

		if t.Location != nil {
			eventMessage.Location = &waE2E.LocationMessage{
				Name:             proto.String(t.Location.Name),
				DegreesLongitude: t.Location.DegreesLongitude,
				DegreesLatitude:  t.Location.DegreesLatitude,
			}
		}

		msg := &waE2E.Message{
			EventMessage: eventMessage,
			MessageContextInfo: &waE2E.MessageContextInfo{
				MessageSecret: msgSecret,
			},
		}

		if t.Presence != nil && *t.Presence > 0 {
			client.SendPresence(r.Context(), types.PresenceAvailable)
			go func() {
				time.Sleep(time.Millisecond * time.Duration(*t.Presence))
			}()
		}

		var contextInfo *waE2E.ContextInfo
		if t.ContextInfo.StanzaID != nil || t.ContextInfo.Participant != nil {
			contextInfo = &t.ContextInfo
			msg.EventMessage.ContextInfo = contextInfo
		}

		resp, err = s.sendMessageWithEchoByID(context.Background(), txtid, recipient, msg, whatsmeow.SendRequestExtra{ID: msgid}, forceEcho)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, errors.New(fmt.Sprintf("Error sending event: %v", err)))
			return
		}

		log.Info().Str("timestamp", fmt.Sprintf("%v", resp.Timestamp)).Str("id", msgid).Msg("Event sent")
		response := map[string]interface{}{"Details": "Sent", "Timestamp": resp.Timestamp, "Id": msgid}
		responseJson, err := json.Marshal(response)
		if err != nil {
			CaptureError(err, r.Context())
			s.Respond(w, r, http.StatusInternalServerError, err)
		} else {
			s.Respond(w, r, http.StatusOK, string(responseJson))
		}
	}
}
