package main

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
	"go.mau.fi/whatsmeow/proto/waE2E"
	"google.golang.org/protobuf/proto"
)

type ButtonFactory struct{}
type ButtonMessageFactory struct{}

type ButtonType string

const (
	ButtonReply        ButtonType = "quick_reply"
	ButtonCopy         ButtonType = "cta_copy"
	ButtonPix          ButtonType = "payment_info"
	ButtonReviewAndPay ButtonType = "review_and_pay"
	ButtonURL          ButtonType = "cta_url"
	ButtonPhone        ButtonType = "cta_call"
)

type ReviewAndPayItemInput struct {
	Name         string
	Quantity     int
	AmountValue  int
	AmountOffset int
}

type ReviewAndPayConfig struct {
	PixKey       string
	MerchantName string
	PixKind      string
	Currency     string
	TotalValue   int
	TotalOffset  int
	Items        []ReviewAndPayItemInput
	ReferenceID  string
	Instructions string
}

func (ButtonFactory) NewPixBtn(key, name, Pixkind string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	btn, err := ButtonPixOrderParamsJSON{}.New(key, name, Pixkind)
	if err != nil {
		return nil, err
	}

	buttonParamsJSON, err := json.Marshal(btn)
	if err != nil {
		return nil, err
	}

	return &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
		Name:             proto.String(string(ButtonPix)),
		ButtonParamsJSON: proto.String(string(buttonParamsJSON)),
	}, nil
}

func (kind ButtonType) pixParams(key, name, Pixkind string) (params map[string]any, err error) {
	btn, err := ButtonPixOrderParamsJSON{}.New(key, name, Pixkind)
	if err != nil {
		return nil, err
	}

	params = make(map[string]any)
	params["order"] = btn

	return params, nil
}

func (ButtonFactory) NewReplyBtn(text, id string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	if id == "" {
		id = uuid.New().String()
	}

	params, err := ButtonReply.replyParams(text, id)
	if err != nil {
		return nil, err
	}

	return ButtonReply.parse(params)
}

func (ButtonFactory) NewCopyBtn(text, code string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	params, err := ButtonCopy.copyParams(text, code)
	if err != nil {
		return nil, err
	}

	return ButtonCopy.parse(params)
}

func (ButtonFactory) NewUrlBtn(text, _url string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	params, err := ButtonURL.urlParams(text, _url)
	if err != nil {
		return nil, err
	}

	return ButtonURL.parse(params)
}

func (ButtonFactory) NewCallBtn(text, phone string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	params, err := ButtonPhone.callParams(text, phone)
	if err != nil {
		return nil, err
	}

	return ButtonPhone.parse(params)
}

func (ButtonFactory) NewReviewPayBtn(key, name, instructions, Pixkind string) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	btn, err := ButtonReviewAndPayParamsJSON{}.New(key, name, instructions, Pixkind)
	if err != nil {
		return nil, err
	}

	buttonParamsJSON, err := json.Marshal(btn)
	if err != nil {
		return nil, err
	}

	return &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
		Name:             proto.String(string(ButtonReviewAndPay)),
		ButtonParamsJSON: proto.String(string(buttonParamsJSON)),
	}, nil
}

func (ButtonFactory) NewReviewPayBtnCustom(cfg ReviewAndPayConfig) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	payment, err := PixPaymentSettings{}.new(cfg.PixKey, cfg.MerchantName, cfg.PixKind)
	if err != nil {
		return nil, err
	}

	var items []PixItem
	subtotalValue := 0
	subtotalOffset := 100
	if len(cfg.Items) > 0 {
		for _, it := range cfg.Items {
			items = append(items, PixItem{
				Amount:     TotalAmount{Value: it.AmountValue, Offset: it.AmountOffset},
				Name:       it.Name,
				RetailerID: fmt.Sprintf("custom-item-%d", time.Now().UnixNano()),
				Quantity:   it.Quantity,
			})
			subtotalValue += it.AmountValue * max(1, it.Quantity)
			if it.AmountOffset > 0 {
				subtotalOffset = it.AmountOffset
			}
		}
	}

	totalValue := cfg.TotalValue
	totalOffset := cfg.TotalOffset
	if totalValue == 0 {
		totalValue = subtotalValue
	}
	if totalOffset == 0 {
		totalOffset = subtotalOffset
	}

	ref := cfg.ReferenceID
	if ref == "" {
		b := make([]byte, 10)
		if _, err := rand.Read(b); err == nil {
			ref = strings.ToUpper(hex.EncodeToString(b))
		}
	}

	order := Order{
		Status:   "pending",
		Items:    items,
		Subtotal: TotalAmount{Value: subtotalValue, Offset: subtotalOffset},
	}

	review := ButtonReviewAndPayParamsJSON{
		ReferenceID:          ref,
		Type:                 "physical-goods",
		PaymentType:          "br",
		PaymentConfiguration: "merchant_categorization_code",
		PaymentSettings:      []PixPaymentSettings{payment},
		Currency:             firstNonEmpty(cfg.Currency, "BRL"),
		TotalAmount:          TotalAmount{Value: totalValue, Offset: totalOffset},
		Order:                order,
		SharePaymentStatus:   false,
		Referral:             "chat_attachment",
	}

	buttonParamsJSON, err := json.Marshal(review)
	if err != nil {
		return nil, err
	}

	return &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
		Name:             proto.String(string(ButtonReviewAndPay)),
		ButtonParamsJSON: proto.String(string(buttonParamsJSON)),
	}, nil
}

type ButtonMessageParams struct {
	Title       string                                                         `json:"title"`
	Body        string                                                         `json:"body"`
	Footer      string                                                         `json:"footer"`
	Buttons     []*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton `json:"buttons"`
	HeaderMedia *HeaderMedia                                                   `json:"header_media,omitempty"`
	ContextInfo *waE2E.ContextInfo                                             `json:"context_info,omitempty"`
}

type HeaderMedia struct {
	Type            MediaType `json:"type"`
	URL             string    `json:"url"`
	Caption         string    `json:"caption,omitempty"`
	MimeType        string    `json:"mimetype,omitempty"`
	FileSHA256      string    `json:"file_sha256,omitempty"`
	FileEncSHA256   string    `json:"file_enc_sha256,omitempty"`
	FileLength      uint64    `json:"file_length,omitempty"`
	DirectPath      string    `json:"direct_path,omitempty"`
	MediaKey        string    `json:"media_key,omitempty"`
	FileName        string    `json:"file_name,omitempty"`
	JPEGThumbnail   []byte    `json:"jpeg_thumbnail,omitempty"`
	Width           int       `json:"width,omitempty"`
	Height          int       `json:"height,omitempty"`
	ThumbnailWidth  uint32    `json:"thumbnail_width,omitempty"`
	ThumbnailHeight uint32    `json:"thumbnail_height,omitempty"`
	PageCount       uint32    `json:"page_count,omitempty"`
}

type MediaType string

const (
	MediaImage    MediaType = "image"
	MediaVideo    MediaType = "video"
	MediaDocument MediaType = "document"
)

func (ButtonMessageFactory) NewMessageButtons(params ButtonMessageParams) (*waE2E.Message, error) {
	title := params.Title
	body := params.Body
	footer := params.Footer
	buttons := params.Buttons
	headerMedia := params.HeaderMedia
	ctx := params.ContextInfo

	if len(title) == 0 {
		return nil, ErrHeaderCantBeNull
	}

	if len(title) > 60 {
		return nil, ErrTitleMax60Char
	}

	if len(body) == 0 {
		body = ""
	}

	if len(body) > 1024 {
		return nil, ErrTextMax1024Char
	}

	if len(footer) > 1024 {
		return nil, ErrFooterMax1024Char
	}

	if len(buttons) == 0 {
		return nil, ErrEmptyButtons
	}

	if len(buttons) > 3 {
		return nil, ErrButtonsLimit
	}

	if ctx == nil {
		ctx = &waE2E.ContextInfo{}
	}

	typePresence := struct {
		reply, copy, url, call, pix, reviewAndPay bool
	}{}

	for _, button := range buttons {
		switch ButtonType(*button.Name) {
		case ButtonReply:
			typePresence.reply = true
		case ButtonCopy:
			typePresence.copy = true
		case ButtonURL:
			typePresence.url = true
		case ButtonPhone:
			typePresence.call = true
		case ButtonPix:
			typePresence.pix = true
		case ButtonReviewAndPay:
			typePresence.reviewAndPay = true
		}
	}

	if typePresence.reply && (typePresence.copy || typePresence.url || typePresence.call || typePresence.pix || typePresence.reviewAndPay) {
		return nil, errors.New("if a ButtonReply is present, other button types are not allowed")
	}

	msgVersion := int32(1)

	header := &waE2E.InteractiveMessage_Header{
		Title:              proto.String(title),
		HasMediaAttachment: proto.Bool(false),
	}

	if headerMedia != nil {

		switch headerMedia.Type {
		case MediaImage:
			img := &waE2E.ImageMessage{
				URL:           proto.String(headerMedia.URL),
				Mimetype:      proto.String(headerMedia.MimeType),
				FileSHA256:    []byte(headerMedia.FileSHA256),
				FileEncSHA256: []byte(headerMedia.FileEncSHA256),
				FileLength:    proto.Uint64(headerMedia.FileLength),
				DirectPath:    proto.String(headerMedia.DirectPath),
				MediaKey:      []byte(headerMedia.MediaKey),
				Caption:       proto.String(headerMedia.Caption),
				JPEGThumbnail: headerMedia.JPEGThumbnail,
			}
			if headerMedia.Width > 0 {
				img.Width = proto.Uint32(uint32(headerMedia.Width))
			}
			if headerMedia.Height > 0 {
				img.Height = proto.Uint32(uint32(headerMedia.Height))
			}
			header.Media = &waE2E.InteractiveMessage_Header_ImageMessage{ImageMessage: img}
		case MediaVideo:
			vid := &waE2E.VideoMessage{
				URL:           proto.String(headerMedia.URL),
				FileSHA256:    []byte(headerMedia.FileSHA256),
				FileEncSHA256: []byte(headerMedia.FileEncSHA256),
				FileLength:    proto.Uint64(headerMedia.FileLength),
				DirectPath:    proto.String(headerMedia.DirectPath),
				MediaKey:      []byte(headerMedia.MediaKey),
				Caption:       proto.String(headerMedia.Caption),
				Mimetype:      proto.String(headerMedia.MimeType),
			}
			if len(headerMedia.JPEGThumbnail) > 0 {
				vid.JPEGThumbnail = headerMedia.JPEGThumbnail
			}
			header.Media = &waE2E.InteractiveMessage_Header_VideoMessage{VideoMessage: vid}
		case MediaDocument:
			doc := &waE2E.DocumentMessage{
				URL:           proto.String(headerMedia.URL),
				Caption:       proto.String(headerMedia.Caption),
				Mimetype:      proto.String(headerMedia.MimeType),
				FileSHA256:    []byte(headerMedia.FileSHA256),
				FileEncSHA256: []byte(headerMedia.FileEncSHA256),
				FileLength:    proto.Uint64(headerMedia.FileLength),
				DirectPath:    proto.String(headerMedia.DirectPath),
				MediaKey:      []byte(headerMedia.MediaKey),
			}
			if headerMedia.FileName != "" {
				doc.FileName = proto.String(headerMedia.FileName)
			}
			if len(headerMedia.JPEGThumbnail) > 0 {
				doc.JPEGThumbnail = headerMedia.JPEGThumbnail
			}
			if headerMedia.ThumbnailWidth > 0 {
				doc.ThumbnailWidth = proto.Uint32(headerMedia.ThumbnailWidth)
			}
			if headerMedia.ThumbnailHeight > 0 {
				doc.ThumbnailHeight = proto.Uint32(headerMedia.ThumbnailHeight)
			}
			if headerMedia.PageCount > 0 {
				doc.PageCount = proto.Uint32(headerMedia.PageCount)
			}
			header.Media = &waE2E.InteractiveMessage_Header_DocumentMessage{DocumentMessage: doc}
		default:
			return nil, fmt.Errorf("unsupported media type: %s", headerMedia.Type)
		}
		header.HasMediaAttachment = proto.Bool(true)
	}

	var messageParams *string
	for _, b := range buttons {
		if b != nil && b.Name != nil && *b.Name == string(ButtonReviewAndPay) {
			empty := "{}"
			messageParams = &empty
			break
		}
	}

	return &waE2E.Message{
		InteractiveMessage: &waE2E.InteractiveMessage{
			Header: header,
			Body: &waE2E.InteractiveMessage_Body{
				Text: proto.String(body),
			},
			Footer: &waE2E.InteractiveMessage_Footer{
				Text: proto.String(footer),
			},
			InteractiveMessage: &waE2E.InteractiveMessage_NativeFlowMessage_{
				NativeFlowMessage: &waE2E.InteractiveMessage_NativeFlowMessage{
					MessageVersion:    &msgVersion,
					Buttons:           buttons,
					MessageParamsJSON: messageParams,
				},
			},
			ContextInfo: ctx,
		},
	}, nil
}

func (ButtonType) params(text string) (params map[string]any, err error) {
	if len(text) == 0 {
		fmt.Println("text", text)
		return nil, ErrTextCantBeNull
	}

	if len(text) > 30 {
		return nil, ErrTextMax30Char
	}

	params = make(map[string]any)
	params["display_text"] = text
	params["disabled"] = false
	return params, nil
}

func (kind ButtonType) replyParams(text, id string) (params map[string]any, err error) {
	params, err = kind.params(text)
	if err != nil {
		return nil, err
	}

	if id == "" {
		return nil, errors.New("id required")
	}

	params["id"] = id

	return params, nil
}

func (kind ButtonType) copyParams(text, code string) (params map[string]any, err error) {
	params, err = kind.params(text)
	if err != nil {
		return nil, err
	}

	if code == "" {
		return nil, errors.New("code required")
	}

	params["copy_code"] = code

	return params, nil
}

func (kind ButtonType) urlParams(text, _url string) (params map[string]any, err error) {
	params, err = kind.params(text)
	if err != nil {
		return nil, err
	}

	if _url == "" {
		return nil, errors.New("url required")
	}

	_, err = url.ParseRequestURI(_url)
	if err != nil {
		return nil, fmt.Errorf("url %s is not valid", _url)
	}

	params["url"] = _url

	return params, nil
}

func (kind ButtonType) callParams(text, phone string) (params map[string]any, err error) {
	params, err = kind.params(text)
	if err != nil {
		return nil, err
	}

	if phone == "" {
		return nil, errors.New("phone required")
	}

	params["phone_number"] = phone

	return params, nil
}

func (kind ButtonType) parse(params map[string]any) (*waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton, error) {
	buttonParamsJSON, err := json.Marshal(params)
	if err != nil {
		return nil, err
	}

	return &waE2E.InteractiveMessage_NativeFlowMessage_NativeFlowButton{
		Name:             proto.String(string(kind)),
		ButtonParamsJSON: proto.String(string(buttonParamsJSON)),
	}, nil
}

type ButtonPixOrderParamsJSON struct {
	Currency        string               `json:"currency"`
	Type            string               `json:"type"`
	TotalAmount     TotalAmount          `json:"total_amount"`
	ReferenceID     string               `json:"reference_id"`
	PaymentSettings []PixPaymentSettings `json:"payment_settings"`
	Order           Order                `json:"order"`
}

func (ButtonPixOrderParamsJSON) New(key, name string, kind string) (ButtonPixOrderParamsJSON, error) {
	payment, err := PixPaymentSettings{}.new(key, name, kind)
	if err != nil {
		return ButtonPixOrderParamsJSON{}, err
	}

	b := make([]byte, 10)
	_, err = rand.Read(b)
	if err != nil {
		return ButtonPixOrderParamsJSON{}, err
	}

	return ButtonPixOrderParamsJSON{
		Currency:        "BRL",
		Type:            "physical-goods",
		TotalAmount:     TotalAmount{}.new(0, 1),
		ReferenceID:     strings.ToUpper(hex.EncodeToString(b)),
		PaymentSettings: []PixPaymentSettings{payment},
		Order:           Order{}.newPixOrder(0, 1),
	}, nil
}

type PixPaymentSettings struct {
	Type          string         `json:"type"`
	PixStaticCode *PixStaticCode `json:"pix_static_code,omitempty"`
	Cards         *Cards         `json:"cards,omitempty"`
}

func (PixPaymentSettings) new(key string, name string, kind string) (PixPaymentSettings, error) {
	code, err := PixStaticCode{}.new(key, name, kind)
	if err != nil {
		return PixPaymentSettings{}, err
	}

	return PixPaymentSettings{
		Type:          "pix_static_code",
		PixStaticCode: code,
		Cards:         Cards{}.new(),
	}, nil
}

type Pixtype string

func (p Pixtype) Valid() error {
	if p == PixPhone {
		return nil
	}

	if p == PixCPF {
		return nil
	}

	if p == PixCNPJ {
		return nil
	}

	if p == PixEmail {
		return nil
	}

	if p == PixEVP {
		return nil
	}

	return fmt.Errorf("%s is not pix type, valid type: %s, %s, %s, %s and %s", p,
		PixPhone,
		PixCPF,
		PixCNPJ,
		PixEmail,
		PixEVP,
	)
}

const (
	PixPhone Pixtype = "PHONE"
	PixCPF   Pixtype = "CPF"
	PixCNPJ  Pixtype = "CNPJ"
	PixEmail Pixtype = "EMAIL"
	PixEVP   Pixtype = "EVP"
)

type PixStaticCode struct {
	Key          string  `json:"key"`
	MerchantName string  `json:"merchant_name"`
	KeyType      Pixtype `json:"key_type"`
}

func (PixStaticCode) new(key, name string, _kind string) (*PixStaticCode, error) {
	if key == "" {
		return nil, fmt.Errorf("pix key required")
	}

	if name == "" {
		return nil, fmt.Errorf("pix merchant name required")
	}

	kind := Pixtype(_kind)
	if err := kind.Valid(); err != nil {
		return nil, err
	}

	return &PixStaticCode{
		Key:          key,
		MerchantName: name,
		KeyType:      kind,
	}, nil
}

type Cards struct {
	Enabled bool `json:"enabled"`
}

func (Cards) new() *Cards {
	return &Cards{Enabled: false}
}

type Order struct {
	Status    string      `json:"status"`
	Items     []PixItem   `json:"items"`
	Subtotal  TotalAmount `json:"subtotal"`
	OrderType *string     `json:"order_type,omitempty"`
	Tax       *int        `json:"tax,omitempty"`
	Shipping  *int        `json:"shipping,omitempty"`
	Discount  *int        `json:"discount,omitempty"`
}

func (Order) newPixOrder(value int, offset int) Order {
	return Order{
		Status: "payment_requested",
		Items: []PixItem{
			PixItem{}.new(value, offset),
		},
		Subtotal:  TotalAmount{}.new(value, offset),
		OrderType: proto.String("ORDER_WITHOUT_AMOUNT"),
	}
}

func (Order) newReviewAndPayOrder(value int, offset int) Order {
	return Order{
		Status: "pending",
		Items: []PixItem{
			PixItem{}.new(value, offset),
		},
		Subtotal: TotalAmount{}.new(value, offset),
	}
}

type PixItem struct {
	Amount     TotalAmount `json:"amount"`
	Name       string      `json:"name"`
	RetailerID string      `json:"retailer_id"`
	Quantity   int         `json:"quantity"`
}

func (PixItem) new(value int, offset int) PixItem {
	timestamp := time.Now().Unix()

	return PixItem{
		Amount:     TotalAmount{}.new(value, offset),
		Name:       "",
		RetailerID: fmt.Sprintf("custom-item-%d", timestamp),
		Quantity:   0,
	}
}

type TotalAmount struct {
	Value  int `json:"value"`
	Offset int `json:"offset"`
}

func (TotalAmount) new(value int, offset int) TotalAmount {
	return TotalAmount{
		Value:  value,
		Offset: offset,
	}
}

func firstNonEmpty(values ...string) string {
	for _, v := range values {
		if strings.TrimSpace(v) != "" {
			return v
		}
	}
	return ""
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

type ButtonReviewAndPayParamsJSON struct {
	ReferenceID          string               `json:"reference_id"`
	Type                 string               `json:"type"`
	PaymentType          string               `json:"payment_type,omitempty"`
	PaymentConfiguration string               `json:"payment_configuration"`
	PaymentSettings      []PixPaymentSettings `json:"payment_settings"`
	Currency             string               `json:"currency"`
	TotalAmount          TotalAmount          `json:"total_amount"`
	Order                Order                `json:"order"`
	SharePaymentStatus   bool                 `json:"share_payment_status"`
	Referral             string               `json:"referral,omitempty"`
}

func (ButtonReviewAndPayParamsJSON) New(key, name, instructions string, kind string) (ButtonReviewAndPayParamsJSON, error) {
	payment, err := PixPaymentSettings{}.new(key, name, kind)
	if err != nil {
		return ButtonReviewAndPayParamsJSON{}, err
	}

	b := make([]byte, 10)
	_, err = rand.Read(b)
	if err != nil {
		return ButtonReviewAndPayParamsJSON{}, err
	}

	return ButtonReviewAndPayParamsJSON{
		ReferenceID:          strings.ToUpper(hex.EncodeToString(b)),
		Type:                 "physical-goods",
		PaymentType:          "br",
		PaymentConfiguration: "merchant_categorization_code",
		PaymentSettings:      []PixPaymentSettings{payment},
		Currency:             "BRL",
		TotalAmount:          TotalAmount{}.new(100000, 1000),
		Order:                Order{}.newReviewAndPayOrder(100000, 1000),
		SharePaymentStatus:   false,
		Referral:             "chat_attachment",
	}, nil
}
